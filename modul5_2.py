"""
                                        Елементи функціонального програмування

                    Функція як об'єкт першого класу

    У програмуванні поняття "функція як об'єкт першого класу" означає, що функції в мові програмування 
використовуються як звичайні об'єкти. Це означає, що функції можна присвоювати змінним, передавати як аргументи 
іншим функціям, повертати як результати інших функцій, а також зберігати в структурах даних, таких як списки, 
словники або класи.
    На практиці це означає, що ми можемо працювати з функціями у Python точно так, як з будь-якими іншими типами 
даних.
    Перше, це присвоїмо функцію змінній.                                    
"""
def my_function():
    print("Hello, world!")

f = my_function
f()
"""
    Тут ми викликаємо не саму функцію, а змінну f(), що призводить до такого самого результату, ніби ми викликали 
саму функцію my_function()

Виведення: Hello, world!

    Функції можуть бути аргументами інших функцій. Припустимо, у нас є декілька функцій для обчислення різних 
математичних операцій. Ми можемо створити функцію apply_operation, яка приймає іншу функцію, як аргумент та 
використовує її для обчислення результату.
"""
from typing import Callable

def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

def apply_operation(a: int, b: int, operation: Callable[[int, int], int]) -> int:
    return operation(a, b)

# Використання
result_add = apply_operation(5, 3, add)
result_multiply = apply_operation(5, 3, multiply)

print(result_add, result_multiply)
"""
Виведення: 8 15

    Коли ми додаємо функцію як аргумент, щоб додати типізацію до цих функцій у Python, використовуються анотації 
типів з модуля typing. Функція apply_operation має, вже знайомі нам анотації типів для a та b, а ось для параметра 
operation анотована як Callable[[int, int], int]. Це означає, що параметр operation це функція, яка приймає два цілі 
числа та повертає ціле число.
    Функції як об'єкт першого класу можуть повертають інші функції. Наприклад, ми можемо створити функцію, яка 
генерує іншу функцію для підняття числа до заданого степеня."""
from typing import Callable

def power(exponent: int) -> Callable[[int], int]:
    def inner(base: int) -> int:
        return base ** exponent
    return inner

# Використання
square = power(2)
cube = power(3)
print(power(2)(4))  # 16
print(power(3)(4))  # 64
print(square(4)) 
print(cube(4))
""" Функція power приймає один аргумент exponent і повертає внутрішню функцію inner. Внутрішня функція inner приймає 
base і використовує збережений exponent для обчислення base ** exponent.
    Коли ми викликаємо power(2), то фактично створюємо нову функцію square, для якої exponent має значення 2. 
Аналогічно, power(3) створює функцію cube, де exponent має значення 3.
    Коли відбувається виклик square(4), внутрішня функція inner обчислює 4 ** 2, що повертає 16. Так само cube(4) 
обчислює 4 ** 3, що повертає 64.

Виведення:

16
64

    І останнє: це зберігання функцій у структурах даних. Наприклад, створимо словник, де ключами будуть назви 
операцій, а значеннями — відповідні функції. """
from typing import Callable, Dict

# Визначення функцій
def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

def power(exponent: int) -> Callable[[int], int]:
    def inner(base: int) -> int:
        return base ** exponent
    return inner

# Використання power для створення функцій square та cube
square = power(2)
cube = power(3)

# Словник операцій
operations: Dict[str, Callable] = {
    'add': add,
    'multiply': multiply,
    'square': square,
    'cube': cube
}

# Використання операцій
result_add = operations['add'](10, 20)  # 30
result_square = operations['square'](5)  # 25
result_cube = operations['cube'](5)  # 125
result_multiply = operations['multiply'](5, 5)  # 25
print("Функція додавання operations['add'](10, 20)",result_add) 
print("Функція піднесення до квадрату operations['square'](5)",result_square)  
print("Функція піднесення до кубу operations['cube'](5)",result_cube)
print("Функція множення operations['multiply'](5, 5)",result_multiply)
""" Наш словник operations містить посилання на всі чотири наші функції. І тепер через operations виконуються 
операції add, cube, multiply або square з відповідними аргументами. Де ключ словника це назва наших функцій.

30
25
125
25

    Зверніть увагу, що тип Dict[str, Callable] означає словник, де ключі - це строки, а значення - це об'єкти, що 
можна викликати. У контексті operations: Dict[str, Callable] це означає, що словник містить назви операцій і 
посилання на функції, які виконують ці операції.
    Таким чином, з функціями у Python можна працювати так само, як і з будь-якими іншими об'єктами. Це відкриває 
перед розробником безліч можливостей, про які ми поговоримо далі.


                        Замикання та каррування  

    Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно, дає 
можливість використати механізм замикань у Python.
    Замикання (closure) в програмуванні — це потужна концепція, особливо в мовах, що підтримують функції вищого 
порядку, як наприклад Python. Замикання відбувається, коли внутрішня функція запам'ятовує стан свого оточення в 
момент свого створення і може використовувати ці змінні навіть після того, як зовнішня функція завершила своє 
виконання.
    Ключові аспекти замикань:
        1. Внутрішня функція має доступ до змінних, визначених у області видимості зовнішньої функції.
        2. Зовнішня функція повертає внутрішню функцію як результат своєї роботи.
        3. Після завершення роботи зовнішньої функції, внутрішня функція зберігає доступ до цих змінних, що відіграє 
        важливу роль у певних програмних патернах та алгоритмах.
    Найпростіше це пояснити на прикладі:                    
"""
def outer_function(msg):
    message = msg

    def inner_function():
        print(message)

    return inner_function

# Створення замикання
my_func = outer_function("Hello, world!")
my_func()
""" У цьому прикладі функція outer_function визначена таким чином, що приймає аргумент msg і створює внутрішню змінну 
message, значення якої ініціалізується переданим аргументом. Усередині outer_function розміщена інша функція, 
inner_function, яка призначена для виведення на екран значення змінної message. Важливим аспектом є те, що 
inner_function використовує змінну message, яка була визначена у зовнішньому лексичному середовищі outer_function.
    Замість того щоб безпосередньо викликати inner_function, outer_function після свого виконання повертає її як 
об'єкт. Це дозволяє функції inner_function зберегти зв'язок зі своїм лексичним середовищем, навіть після завершення 
виконання outer_function.
    Коли виконується дія my_func = outer_function("Hello, world!"), то функція my_func стає посиланням на функцію 
inner_function. Чому? Тому, що коли викликається функція outer_function, вона повертає посилання на функцію 
inner_function. Далі коли ми викликаємо my_func() виконується насправді саме функція inner_function , вона успішно 
виводить "Hello, world!". Це відбувається завдяки збереженню inner_function доступу до змінної message, що була 
визначена в outer_function. Така поведінка є класичним прикладом замикання, де внутрішня функція зберігає стан 
змінних зі свого лексичного контексту.
    Як практично це можна використовувати? Насправді досить багато де використовується замикання, але розглянемо 
більш зрозумілий для початківця приклад. Ми створимо замикання, яке буде зберігати інформацію про кількість разів 
виклику функції. """
from typing import Callable

def counter() -> Callable[[], int]:
    count = 0

    def increment() -> int:
        # використовуємо nonlocal, щоб змінити змінну в замиканні
        nonlocal count  
        count += 1
        return count

    return increment

# Створення лічильника
count_calls = counter()

# Виклики лічильника
print(count_calls())  # Виведе 1
print(count_calls())  # Виведе 2
print(count_calls())  # Виведе 3
""" Це приклад замикання, де increment замкнула в собі змінну count і має до неї доступ навіть після того, як 
зовнішня функція counter завершує своє виконання. Завдяки цьому, count_calls зберігає стан між викликами. Кожен раз, 
коли ми викликаємо count_calls, вона викликає increment, яка замкнула в собі count.
Виведення:
1
2
3
    Так можна створити функцію, яка може змінювати поведінку в залежності від того скільки викликів вже відбулося.

    Каррінг (currying) — це техніка в програмуванні, коли функція, яка приймає кілька аргументів, перетворюється на 
    послідовність функцій, кожна з яких приймає один аргумент. Названий на честь логіка Гаскеля Каррі, каррінг 
    дозволяє зробити функції більш гнучкими і сприяє створенню високо модульного та читабельного коду.

    Припустимо, у нас є функція, яка приймає два аргументи: 

 def add(a, b):
    return a + b

Застосувавши каррінг до цієї функції, ми перетворимо її на двій функції, кожна з яких приймає по одному аргументу:"""
def add(a):
    def add_b(b):
        return a + b
    return add_b

# Використання:
add_5 = add(5)
result = add_5(10)
print(result)
# Виведення: 15
""" Тут функція add приймає перший аргумент a і повертає функцію add_b. Сама функція add_b приймає другий аргумент b 
і повертає результат a + b. Фактично ми перетворили виклик функції add на виклик двох функцій.
    У функціональному програмуванні такий підхід дозволяє легко використати функцію знову і створювати нові функції 
на базі наявних. Після того як ми розглянули саму техніку каррінгу давайте подивимось на якийсь практичний приклад 
використання.

    Припустимо, у нас є функція для обчислення знижки на товар. Ця функція приймає відсоток знижки і остаточну ціну 
товару. """
def apply_discount(price: float, discount_percentage: int) -> float:
    return price * (1 - discount_percentage / 100)

# Використання
discounted_price = apply_discount(500, 10)  # Знижка 10% на ціну 500
print(discounted_price)

discounted_price = apply_discount(500, 20)  # Знижка 20% на ціну 500
print(discounted_price)
""" Виведення:
450.0
400.0
    Використовуючи каррінг, ми можемо створити більш гнучку структуру для роботи з різними типами знижок.
    
    Перетворимо функцію apply_discount, використовуючи каррінг. Це дозволить нам створити "замовлені" функції для 
різних рівнів знижок, кожна з яких буде приймати тільки ціну товару"""
from typing import Callable

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Каррінг в дії
ten_percent_discount = discount(10)
twenty_percent_discount = discount(20)

# Застосування знижок
discounted_price = ten_percent_discount(500)  # 450.0
print(discounted_price)

discounted_price = twenty_percent_discount(500)  # 400.0
print(discounted_price)
""" Виведення:
450.0
400.0

    Таким чином, за допомогою каррінгу, ми розділили функцію на дві частини. Спочатку ми створюємо функції з певним 
відсотком знижки ten_percent_discount та twenty_percent_discount, а потім використовуємо ці функції для обчислення 
зниженої ціни. Це робить код більш гнучким і дозволяє легко створювати функції для різних рівнів знижок.
    Ми можемо піти далі та створити словник, де ключами будуть назви знижок, а значеннями — відповідні функції 
обчислення знижки, створені за допомогою каррінгу. Це дозволить нам легко вибирати потрібну функцію знижки зі 
словника. """
from typing import Callable, Dict

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Створення словника з функціями знижок
discount_functions: Dict[str, Callable] = {
    "10%": discount(10),
    "20%": discount(20),
    "30%": discount(30)
}

# Використання функції зі словника
price = 500
discount_type = "20%"
print(discount_functions)
discounted_price = discount_functions[discount_type](price)
print(f"Ціна зі знижкою {discount_type}: {discounted_price}")
""" Ми створюємо словник discount_functions, де кожному типу знижки "10%", "20%" та "30%" відповідає функція з 
каррінгом, що обчислює знижку. І тепер щоб застосувати знижку, ми вибираємо потрібну функцію зі словника за допомогою 
ключа discount_type і передаємо їй ціну товару. Виведення:

        Ціна зі знижкою 20%: 400.0

    Цей підхід забезпечує велику гнучкість, бо ми можемо легко додавати, видаляти або змінювати знижки в словнику 
без необхідності зміни основного коду програми. 

                        Декоратори
                        
    Є такий шаблон проектування — Декоратор. Цей шаблон полягає в тому, щоб розширювати функціонал який вже існує, 
не вносячи змін в код цього самого функціоналу.
    Декоратори в Python — це дуже потужний і корисний інструмент, який дозволяє змінювати поведінку функцій або 
методів без зміни їхнього вихідного коду. Вони є прикладом функцій вищого порядку, які приймають іншу функцію як 
аргумент та повертають нову функцію.
    Наприклад, у нас є якась дуже складна і важлива функція complicated:

def complicated(x: int, y: int) -> int:
    return x + y

    І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логування до цієї функції, виводити в 
консоль щоразу те, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.
    Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:"""
def complicated(x: int, y: int) -> int:
    return x + y

def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

complicated = logger(complicated)
# print(complicated) #<function logger.<locals>.inner at 0x00000282F3878E00>
# complicated(2, 3)
print(complicated(2, 3))
""" Декоратор logger приймає функцію як аргумент і повертає нову функцію complicated = logger(complicated). Декорована 
функція зберігає свою оригінальну функціональність, але додатково отримує нову поведінку або модифікації.
    Тепер, викликаючи complicated, ми побачимо у консолі, з якими аргументами її викликали і що вона повернула. При 
цьому, код самої complicated жодним чином не змінився і спосіб роботи з нею також.

Викликається функція: complicated: 2, 3
Функція complicated завершила виконання: 5
5

    Проте такий код не занадто легкий для читання й досить великий за обсягом. Крім того, в коді легко пропустити рядок 
complicated = logger(complicated) і не занадто просто зрозуміти, звідки виходитиме доданий до complicated функціонал.
    Щоб спростити застосування цього шаблону проектування, в Python є спеціальний синтаксис декоратора. Декоратори 
використовуються з синтаксисом @, що робить їх застосування простим та елегантним. Точно той самий код, який робить в 
точності те саме, можна записати у вигляді: """
def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
""" Функція logger є декоратором. Вона приймає функцію func і повертає нову функцію inner. Функція inner виконує 
додаткові дії (логування) до і після виконання func. При оголошенні функції complicated, ми використовуємо @logger, 
щоб застосувати декоратор. Тепер при кожному виклику complicated будуть виконуватися додаткові дії логування. Тепер 
у коді явно видно, що complicated була задекорована logger у тому самому місці, де complicated була оголошена.

    Декоратори широко використовуються для різних цілей. Основні застосування це:
        - Логування - запис інформації про виклики функцій для забезпечення прозорості та відстеження.
        - Перевірка доступу - перевірка прав користувача перед виконанням функції, щоб контролювати доступ.
        - Кешування - збереження результатів функції для підвищення ефективності та скорочення часу виконання.
        - Перевірка аргументів - аналіз та модифікація аргументів перед їх передачею функції для забезпечення 
        правильності виклику.

    В майбутньому ми побачимо, що в веб-розробці декоратори стануть нашими незмінними помічниками.
    Дуже важливо при створенні декораторів використовувати модуль functools, це необхідно для збереження метаданих 
оригінальної функції, яку ми декоруємо. Функція functools.wraps допомагає в цьому, зберігаючи інформацію про 
оригінальну функцію, як-от ім'я функції та документацію. """
from functools import wraps

def logger(func):
    @wraps(func)
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
print(complicated.__name__)
""" У цьому прикладі functools.wraps(func) застосовується до внутрішньої функції inner. Вона "копіює" метадані 
(ім'я функції, документацію тощо) від func до inner. Завдяки цьому, коли ми викликаємо print(complicated.__name__), 
ми отримуємо метадані оригінальної функції complicated, а не функції inner з декоратору logger.

    Виведення:
        Викликається функція: complicated: 2, 3
        Функція complicated завершила виконання: 5
        5
        complicated

    Це важливо для збереження очікуваної функціональності декорованої функції, особливо коли працюєте з декораторами 
у більш складних програмах або бібліотеках. Використання functools.wraps допомагає уникнути плутанини, пов'язаної з 
втратою метаданих оригінальної функції. 

                        Comprehensions


    В програмуванні досить часто необхідно створити заповнену колекцію. Зробити це одним виразом не можна, доводиться 
писати цикл. Наприклад, щоб створити список квадратів чисел від 1 до 5, треба написати наступний код:"""
sq = []
for i in range(1, 6):
    sq.append(i**2)
print("Квадрати чисел від 1 до 5",sq)

""" Виведення: Квадрати чисел від 1 до 5 [1, 4, 9, 16, 25]
    Подібні операції, які ми робимо зі змінюваними колекціями списків list, словників dict та множин set у циклі for. 
Для спрощення таких операцій в Python ввели конструкції Comprehensions .
    Comprehensions в Python - це спосіб компактного створення колекцій на основі наявних колекцій. Python підтримує 
кілька видів comprehensions: для списків (list comprehensions), множин (set comprehensions) та словників (dictionary 
comprehensions). Вони дозволяють писати вирази для створення нових колекцій з меншою кількістю коду, ніж при 
використанні циклів.

                        List Comprehensions

    List comprehensions використовуються для створення нових списків та мають наступний синтаксис:

            [new_item for item in iterable if condition]

    Як це виглядає на практиці? Попередній приклад можна записати наступним чином:"""
sq = [x**2 for x in range(1, 6)]
print("Квадрати чисел від 1 до 5",sq)
""" Створення списку квадратів чисел від 1 до 5: [1, 4, 9, 16, 25]
    
    Умова в синтаксисі дозволяє нам створювати списки за якоюсь умовою. Створимо список квадратів парних чисел від 1 до 9: """
even_squares = [x**2 for x in range(1, 10) if x % 2 == 0]
print(even_squares)
""" Виведення: [4, 16, 36, 64]
    Тут ми створюємо список квадратів чисел від 1 до 9, але тільки для парних чисел. Умова if x % 2 == 0 фільтрує 
числа, залишаючи тільки парні. Таким чином, ми отримуємо список квадратів парних чисел від 1 до 9."""

# В звичайному стилі попередній приклад прийшлось би записувати так:
even_squares = []
for x in range(1, 10):
    if x % 2 == 0:
        even_squares.append(x**2)

print(even_squares)  # Виведе [4, 16, 36, 64]
""" У цьому коді використовується цикл for для ітерації чисел від 1 до 9. Для кожного числа x перевіряється, чи є воно парним, 
тобто чи ділиться на 2 без залишку. Якщо так, його квадрат додається до списку even_squares. На виході ми отримуємо список 
квадратів усіх парних чисел у заданому діапазоні. Скільки коду вийшло, замість одного рядка Comprehensions цілих чотири!
    Як бачимо Comprehensions зазвичай коротші та легші для розуміння, ніж еквівалентні цикли. Але головне вони часто більш 
ефективні за цикли через оптимізації в Python.

                        Set Comprehensions

    Set comprehensions використовуються аналогічно list comprehensions, але для створення множин.

    Синтаксис: {new_item for item in iterable if condition}

    Збережімо множини квадратів чисел зі списку:"""
    
numbers = [1, 4, 1, 3, 2, 5, 2, 6]
sq = {i ** 2 for i in numbers}
print(sq)

""" Виведення: {1, 4, 9, 16, 25, 36}
    Тут ми створюємо множину квадратів чисел зі списку numbers. Зверніть увагу, що множини не допускають дублювання
елементів, тому результатом буде множина унікальних квадратів чисел. Якщо б ми використовували list comprehension,
то отримали б список з дублюваннями.
    Set Comprehensions також підтримує умови. Створимо множину квадратів непарних чисел від 1 до 9:"""
    
odd_squares = {x**2 for x in range(1, 10) if x % 2 != 0}
print(odd_squares)

""" Виведення: {1, 9, 25, 49, 81}
    Тут ми створюємо множину квадратів непарних чисел від 1 до 9. Умова if x % 2 != 0 фільтрує числа, залишаючи тільки
непарні. Таким чином, ми отримуємо множину квадратів непарних чисел від 1 до 9.


                        Dictionary Comprehensions

    Dictionary comprehensions використовуються для створення нових словників. Для словників синтаксис comprehension 
трохи відрізняється, оскільки потрібно явно вказати ключ та значення

        Синтаксис: {key: value for item in iterable if condition}

    Створимо словник, де ключ - число, а значення - його квадрат."""

sq = {x: x**2 for x in range(1, 10)}
print(" Словник з квадратами чисел від 1 до 9", sq)
""" Виведення: Словник з квадратами чисел від 1 до 9 {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

    Тут ми створюємо словник, де ключем є число x, а значенням - його квадрат x**2. Таким чином, ми отримуємо словник
з квадратами чисел від 1 до 9. Основна відмінність за синтаксисом — це двокрапка між ключем і значенням в лівій 
частині виразу всередині дужок.
    Створимо словник, де ключами будуть числа, а значеннями — їх квадрати, але тільки для чисел, що більші за 5:"""
sq_dict = {x: x**2 for x in range(1, 10) if x > 5}
print(sq_dict)
""" У цьому випадку if x > 5 обмежує включення тільки тих чисел, що задовольняють умові. {6: 36, 7: 49, 8: 64, 9: 81}

    Comprehensions ідеально підходять для простих випадків, коли вам потрібно трансформувати елементи колекції або 
фільтрувати їх за певною умовою. Вони роблять код більш читабельним і зменшують потребу в багаторядкових циклах і 
умовних конструкціях. Однак важливо використовувати їх з обережністю, щоб не перевантажити один рядок занадто 
складною логікою. 


                                        Функціональне програмування в Python

    Функціональне програмування є парадигмою програмування, яка акцентує на використанні функцій та їх композиціях 
для обробки даних та побудови логіки програми. Хоча Python не є чисто функціональною мовою, він підтримує багато 
аспектів функціонального програмування.

                        Лямбда-функції

    Буває, що нам потрібна функція, суть якої можна викликати, передавши їй аргументи, але сама функція дуже проста
і її всю можна описати одним виразом. У таких ситуаціях немає особливого сенсу створювати функцію, використовуючи
стандартний синтаксис і захаращувати простір імен.
    Спеціально для таких випадків у Python є лямбда-функції, відомі також як анонімні функції, які є важливою частиною 
Python і використовуються для створення маленьких, однорядкових функцій.

                        Синтаксис лямбда-функції є наступним: lambda arguments: expression

    Тут lambda — це ключове слово, що вказує на початок лямбда-функції. arguments — це список аргументів, які приймає 
    функція, а expression — це вираз, який буде виконано та його результат повернуто.
    
    Розглянемо приклад"""

add = lambda x, y: x + y
print(add(5, 3))  # Виведе 8

""" У прикладі ми створили лямбда-функцію add, яка повертає суму двох чисел. Насправді це поганий тон зберігати лямбда-функції 
у змінних, вони повинні створюватися там, де будуть використовуватися і більше ніде у коді не залишають слідів. """

print((lambda x, y: x + y)(5, 3))  # Виведе 8

""" Отже, що ми бачимо. Лямбда-функції не мають імені. Зазвичай використовуються для написання коротких функцій. Можуть містити 
тільки один вираз і не можуть містити блоки команд наприклад, цикли або умовні конструкції.
    Лямбда-функції часто використовуються як аргументи для функцій вищого порядку, таких як map(), filter() або sorted(). 
Наприклад зворотне сортування списку для sorted(): """
nums = [1, 2, 3, 4, 5]
nums_sorted = sorted(nums, key=lambda x: -x)
print(nums_sorted)
""" Виведення:[5, 4, 3, 2, 1]

    Лямбда-функції ідеально підходять для виконання невеликих функціональних операцій, які не вимагають написання окремої 
іменованої функції. Вони є корисним інструментом у Python, але їх слід використовувати обережно, щоб зберегти читабельність 
коду. У випадках, коли логіка стає складною, краще використовувати звичайні функції з визначеним ім'ям. 

                        Функція map

    Один з прикладів використання лямбда-функцій — це генератор map. Функція map() є функцією вищого порядку, що означає, що 
вона приймає іншу функцію як аргумент. map() використовується для застосування заданої функції до кожного елемента об'єкта 
ітерації, наприклад списку, та повертає ітератор, який виробляє результати.

                        Синтаксис: map(function, iterable, ...)

            function - функція, яку треба застосувати до кожного елемента в iterable.
            iterable - об'єкт ітерації (список, кортеж тощо), елементи якого будуть оброблятися function.

    Давайте напишемо за допомогою map генератор, який підносить числа із списку numbers до квадрату:"""

numbers = [1, 2, 3, 4, 5]
for i in map(lambda x: x ** 2, numbers):
    print(i)
""" Виведення:

1
4
9
16
25

    В якості першого аргументу у map ми передали лямбда-функцію lambda x: x ** 2, яка повертає x у степені 2.
    В результаті виконання виразу map(lambda x: x ** 2, numbers) ми отримаємо генератор, яким пройшлися в циклі 
for та вивели значення на кожній ітерації функцією print.
    Якщо ми хочем отримати список, а не генератор то код можна записати так:"""
numbers = [1, 2, 3, 4, 5]
squared_nums = list(map(lambda x: x ** 2, numbers))
print(squared_nums)
""" Виведення: [1, 4, 9, 16, 25]

    Можна застосувати map до декількох списків:"""
nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
sum_nums = map(lambda x, y: x + y, nums1, nums2)

print(list(sum_nums))
""" Тут map() застосовує лямбда-функцію до елементів обох списків одночасно.

[5, 7, 9]

    Але після того як у Python з'явився list comprehensions його використовують для того ж самого призначення, що 
забезпечує більшу читабельність та виразність.

Замість використання функції map():

numbers = [1, 2, 3, 4, 5]
squared_nums = list(map(lambda x: x ** 2, numbers))
print(squared_nums)

Ми використаємо list comprehensions: """

nums = [1, 2, 3, 4, 5]
squared_nums = [x * x for x in nums]
print(squared_nums)
""" Виведення: [1, 4, 9, 16, 25]

    List comprehensions роблять код більш компактним і легким для читання. Вони дозволяють створювати нові списки
на основі існуючих з використанням простого синтаксису, що робить їх більш виразними та зрозумілими.

    Для двох списків ми теж можемо використати list comprehensions за допомогою функції zip"""
nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
sum_nums = [x + y for x, y in zip(nums1, nums2)]
print(sum_nums)
""" Виведення: [5, 7, 9]

    Тут ми використовуємо zip для об'єднання двох списків nums1 і nums2 в кортежі, а потім застосовуємо list comprehensions
для обчислення суми відповідних елементів. Це робить код більш читабельним і зрозумілим, ніж використання map з лямбда-функцією.
    Загалом переваги list comprehensions це читабельність та гнучкість. Втім вибір між map() та list comprehensions 
залежить від конкретної ситуації та переваг програміста.

                        Функція filter

    Функція filter() використовується для фільтрації об'єктів ітерації, таких як списки або кортежі, за допомогою заданої функції. 
Вона створює ітератор, який містить тільки ті елементи об'єкта ітерації, для яких функція-фільтр повертає True.
    Нагадаємо, що у Python можна будь-який тип привести до boolean. До False приводяться 0, None та порожні контейнери. Рядки, 
списки, словники, множини, кортежі, всі інші випадки приводяться до True.

                        Синтаксис filter(): filter(function, iterable)

                function - функція, яка визначає, чи слід включати елемент у результат. Ця функція повинна приймати 
                один аргумент і повертати булеве значення True або False.
                iterable - об'єкт ітерації (наприклад, список, кортеж), елементи якого будуть перевірятися функцією function.

    Наприклад, виведемо список чисел, які є парними в інтервалі від 1 до 10:"""
even_nums = filter(lambda x: x % 2 == 0, range(1, 11))
print(list(even_nums))
""" У цьому прикладі ми передали у filter лямбда функцію lambda x: x % 2 == 0, яка повертає чи залишок від ділення 
дорівнює 0. Для кожного елемента послідовності з генератора range(1, 11) функція filter виконала перевірку лямбда-функцією
та, якщо лямбда повернула True результат, то цей результат потрапляє у відфільтровану послідовність на виході.

[2, 4, 6, 8, 10]

Не обов'язково використовувати lambda функцію. """
def is_positive(x):
    return x > 0

nums = [-2, -1, 0, 1, 2]
positive_nums = filter(is_positive, nums)

print(list(positive_nums))
""" У цьому прикладі filter() використовує функцію is_positive для відбору тільки додатних чисел: [1, 2]
    Інший приклад, давайте відфільтруємо з рядка літери, щоб залишилися лише літери нижнього регістру: """

some_str = 'Видавництво А-БА-БА-ГА-ЛА-МА-ГА'
new_str = ''.join(list(filter(lambda x: x.islower(), some_str)))
print(new_str)
""" Виведення: видавництво
    Тут ми використовуємо метод islower() для перевірки, чи є символ літерою нижнього регістру. Функція filter()
створює ітератор, який містить тільки ті символи, які задовольняють цю умову. Потім ми об'єднуємо їх у рядок за допомогою
методу join().
    Хоча filter() може бути корисним для багатьох сценаріїв, у деяких випадках list comprehensions можуть 
забезпечити більш читабельний та ефективний спосіб досягнення тих самих цілей.
    Розглянемо, як можна замінити filter() на list comprehensions:"""
nums = [1, 2, 3, 4, 5, 6]
even_nums = [x for x in nums if x % 2 == 0]
print(even_nums)
""" Отримаємо той же самий список: [2, 4, 6]
    Для рядка літер: """
some_str = 'Видавництво А-БА-БА-ГА-ЛА-МА-ГА'

new_str = ''.join([x for x in some_str if x.islower()])
print(new_str)

""" Таке саме виведення: идавництво

    Однак в цілому вибір між використанням filter() та list comprehensions залежить від конкретного випадку 
та особистих переваг програміста. 

                        Функція any

    Функція any() є вбудованою функцією, яка повертає True, якщо хоча б один елемент із заданого об'єкта ітерації 
є істинним. Якщо об'єкт ітерації порожній або всі його елементи є хибними, то any() повертає False.
    Розглянемо декілька прикладів, щоб зрозуміти принцип роботи функції.
    Перевіримо, чи наявний хоч один істинний елемент у списку?"""

nums = [0, False, 5, 0]
result = any(nums)  
print(result)

""" Код поверне True, оскільки 5 є істинним значенням в списку nums
    В функцію можна передавати генератор або list comprehensions. Наприклад перевіримо чи є в списку парні числа? """

nums = [1, 3, 5, 7, 9]
result = any(x % 2 == 0 for x in nums)  
print(result)

""" Код поверне False, оскільки немає парних чисел в списку nums

    Основне застосування функції any у сценаріях, де потрібно визначити, чи хоча б один елемент в колекції 
відповідає певній умові. Досить часто її використовують для поєднання з іншими функціями, такими як map() 
або list comprehensions, для більш складних умов перевірки. """




