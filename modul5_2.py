"""
                                        Елементи функціонального програмування

                    Функція як об'єкт першого класу

    У програмуванні поняття "функція як об'єкт першого класу" означає, що функції в мові програмування 
використовуються як звичайні об'єкти. Це означає, що функції можна присвоювати змінним, передавати як аргументи 
іншим функціям, повертати як результати інших функцій, а також зберігати в структурах даних, таких як списки, 
словники або класи.
    На практиці це означає, що ми можемо працювати з функціями у Python точно так, як з будь-якими іншими типами 
даних.
    Перше, це присвоїмо функцію змінній.                                    
"""
def my_function():
    print("Hello, world!")

f = my_function
f()
"""
    Тут ми викликаємо не саму функцію, а змінну f(), що призводить до такого самого результату, ніби ми викликали 
саму функцію my_function()

Виведення: Hello, world!

    Функції можуть бути аргументами інших функцій. Припустимо, у нас є декілька функцій для обчислення різних 
математичних операцій. Ми можемо створити функцію apply_operation, яка приймає іншу функцію, як аргумент та 
використовує її для обчислення результату.
"""
from typing import Callable

def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

def apply_operation(a: int, b: int, operation: Callable[[int, int], int]) -> int:
    return operation(a, b)

# Використання
result_add = apply_operation(5, 3, add)
result_multiply = apply_operation(5, 3, multiply)

print(result_add, result_multiply)
"""
Виведення: 8 15

    Коли ми додаємо функцію як аргумент, щоб додати типізацію до цих функцій у Python, використовуються анотації 
типів з модуля typing. Функція apply_operation має, вже знайомі нам анотації типів для a та b, а ось для параметра 
operation анотована як Callable[[int, int], int]. Це означає, що параметр operation це функція, яка приймає два цілі 
числа та повертає ціле число.
    Функції як об'єкт першого класу можуть повертають інші функції. Наприклад, ми можемо створити функцію, яка 
генерує іншу функцію для підняття числа до заданого степеня."""
from typing import Callable

def power(exponent: int) -> Callable[[int], int]:
    def inner(base: int) -> int:
        return base ** exponent
    return inner

# Використання
square = power(2)
cube = power(3)
print(power(2)(4))  # 16
print(power(3)(4))  # 64
print(square(4)) 
print(cube(4))
""" Функція power приймає один аргумент exponent і повертає внутрішню функцію inner. Внутрішня функція inner приймає 
base і використовує збережений exponent для обчислення base ** exponent.
    Коли ми викликаємо power(2), то фактично створюємо нову функцію square, для якої exponent має значення 2. 
Аналогічно, power(3) створює функцію cube, де exponent має значення 3.
    Коли відбувається виклик square(4), внутрішня функція inner обчислює 4 ** 2, що повертає 16. Так само cube(4) 
обчислює 4 ** 3, що повертає 64.

Виведення:

16
64

    І останнє: це зберігання функцій у структурах даних. Наприклад, створимо словник, де ключами будуть назви 
операцій, а значеннями — відповідні функції. """
from typing import Callable, Dict

# Визначення функцій
def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

def power(exponent: int) -> Callable[[int], int]:
    def inner(base: int) -> int:
        return base ** exponent
    return inner

# Використання power для створення функцій square та cube
square = power(2)
cube = power(3)

# Словник операцій
operations: Dict[str, Callable] = {
    'add': add,
    'multiply': multiply,
    'square': square,
    'cube': cube
}

# Використання операцій
result_add = operations['add'](10, 20)  # 30
result_square = operations['square'](5)  # 25
result_cube = operations['cube'](5)  # 125
result_multiply = operations['multiply'](5, 5)  # 25
print("Функція додавання operations['add'](10, 20)",result_add) 
print("Функція піднесення до квадрату operations['square'](5)",result_square)  
print("Функція піднесення до кубу operations['cube'](5)",result_cube)
print("Функція множення operations['multiply'](5, 5)",result_multiply)
""" Наш словник operations містить посилання на всі чотири наші функції. І тепер через operations виконуються 
операції add, cube, multiply або square з відповідними аргументами. Де ключ словника це назва наших функцій.

30
25
125
25

    Зверніть увагу, що тип Dict[str, Callable] означає словник, де ключі - це строки, а значення - це об'єкти, що 
можна викликати. У контексті operations: Dict[str, Callable] це означає, що словник містить назви операцій і 
посилання на функції, які виконують ці операції.
    Таким чином, з функціями у Python можна працювати так само, як і з будь-якими іншими об'єктами. Це відкриває 
перед розробником безліч можливостей, про які ми поговоримо далі.


                        Замикання та каррування  

    Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно, дає 
можливість використати механізм замикань у Python.
    Замикання (closure) в програмуванні — це потужна концепція, особливо в мовах, що підтримують функції вищого 
порядку, як наприклад Python. Замикання відбувається, коли внутрішня функція запам'ятовує стан свого оточення в 
момент свого створення і може використовувати ці змінні навіть після того, як зовнішня функція завершила своє 
виконання.
    Ключові аспекти замикань:
        1. Внутрішня функція має доступ до змінних, визначених у області видимості зовнішньої функції.
        2. Зовнішня функція повертає внутрішню функцію як результат своєї роботи.
        3. Після завершення роботи зовнішньої функції, внутрішня функція зберігає доступ до цих змінних, що відіграє 
        важливу роль у певних програмних патернах та алгоритмах.
    Найпростіше це пояснити на прикладі:                    
"""
def outer_function(msg):
    message = msg

    def inner_function():
        print(message)

    return inner_function

# Створення замикання
my_func = outer_function("Hello, world!")
my_func()
""" У цьому прикладі функція outer_function визначена таким чином, що приймає аргумент msg і створює внутрішню змінну 
message, значення якої ініціалізується переданим аргументом. Усередині outer_function розміщена інша функція, 
inner_function, яка призначена для виведення на екран значення змінної message. Важливим аспектом є те, що 
inner_function використовує змінну message, яка була визначена у зовнішньому лексичному середовищі outer_function.
    Замість того щоб безпосередньо викликати inner_function, outer_function після свого виконання повертає її як 
об'єкт. Це дозволяє функції inner_function зберегти зв'язок зі своїм лексичним середовищем, навіть після завершення 
виконання outer_function.
    Коли виконується дія my_func = outer_function("Hello, world!"), то функція my_func стає посиланням на функцію 
inner_function. Чому? Тому, що коли викликається функція outer_function, вона повертає посилання на функцію 
inner_function. Далі коли ми викликаємо my_func() виконується насправді саме функція inner_function , вона успішно 
виводить "Hello, world!". Це відбувається завдяки збереженню inner_function доступу до змінної message, що була 
визначена в outer_function. Така поведінка є класичним прикладом замикання, де внутрішня функція зберігає стан 
змінних зі свого лексичного контексту.
    Як практично це можна використовувати? Насправді досить багато де використовується замикання, але розглянемо 
більш зрозумілий для початківця приклад. Ми створимо замикання, яке буде зберігати інформацію про кількість разів 
виклику функції. """
from typing import Callable

def counter() -> Callable[[], int]:
    count = 0

    def increment() -> int:
        # використовуємо nonlocal, щоб змінити змінну в замиканні
        nonlocal count  
        count += 1
        return count

    return increment

# Створення лічильника
count_calls = counter()

# Виклики лічильника
print(count_calls())  # Виведе 1
print(count_calls())  # Виведе 2
print(count_calls())  # Виведе 3
""" Це приклад замикання, де increment замкнула в собі змінну count і має до неї доступ навіть після того, як 
зовнішня функція counter завершує своє виконання. Завдяки цьому, count_calls зберігає стан між викликами. Кожен раз, 
коли ми викликаємо count_calls, вона викликає increment, яка замкнула в собі count.
Виведення:
1
2
3
    Так можна створити функцію, яка може змінювати поведінку в залежності від того скільки викликів вже відбулося.

    Каррінг (currying) — це техніка в програмуванні, коли функція, яка приймає кілька аргументів, перетворюється на 
    послідовність функцій, кожна з яких приймає один аргумент. Названий на честь логіка Гаскеля Каррі, каррінг 
    дозволяє зробити функції більш гнучкими і сприяє створенню високо модульного та читабельного коду.

    Припустимо, у нас є функція, яка приймає два аргументи: 

 def add(a, b):
    return a + b

Застосувавши каррінг до цієї функції, ми перетворимо її на двій функції, кожна з яких приймає по одному аргументу:"""
def add(a):
    def add_b(b):
        return a + b
    return add_b

# Використання:
add_5 = add(5)
result = add_5(10)
print(result)
# Виведення: 15
""" Тут функція add приймає перший аргумент a і повертає функцію add_b. Сама функція add_b приймає другий аргумент b 
і повертає результат a + b. Фактично ми перетворили виклик функції add на виклик двох функцій.
    У функціональному програмуванні такий підхід дозволяє легко використати функцію знову і створювати нові функції 
на базі наявних. Після того як ми розглянули саму техніку каррінгу давайте подивимось на якийсь практичний приклад 
використання.

    Припустимо, у нас є функція для обчислення знижки на товар. Ця функція приймає відсоток знижки і остаточну ціну 
товару. """
def apply_discount(price: float, discount_percentage: int) -> float:
    return price * (1 - discount_percentage / 100)

# Використання
discounted_price = apply_discount(500, 10)  # Знижка 10% на ціну 500
print(discounted_price)

discounted_price = apply_discount(500, 20)  # Знижка 20% на ціну 500
print(discounted_price)
""" Виведення:
450.0
400.0
    Використовуючи каррінг, ми можемо створити більш гнучку структуру для роботи з різними типами знижок.
    
    Перетворимо функцію apply_discount, використовуючи каррінг. Це дозволить нам створити "замовлені" функції для 
різних рівнів знижок, кожна з яких буде приймати тільки ціну товару"""
from typing import Callable

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Каррінг в дії
ten_percent_discount = discount(10)
twenty_percent_discount = discount(20)

# Застосування знижок
discounted_price = ten_percent_discount(500)  # 450.0
print(discounted_price)

discounted_price = twenty_percent_discount(500)  # 400.0
print(discounted_price)
""" Виведення:
450.0
400.0

    Таким чином, за допомогою каррінгу, ми розділили функцію на дві частини. Спочатку ми створюємо функції з певним 
відсотком знижки ten_percent_discount та twenty_percent_discount, а потім використовуємо ці функції для обчислення 
зниженої ціни. Це робить код більш гнучким і дозволяє легко створювати функції для різних рівнів знижок.
    Ми можемо піти далі та створити словник, де ключами будуть назви знижок, а значеннями — відповідні функції 
обчислення знижки, створені за допомогою каррінгу. Це дозволить нам легко вибирати потрібну функцію знижки зі 
словника. """
from typing import Callable, Dict

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Створення словника з функціями знижок
discount_functions: Dict[str, Callable] = {
    "10%": discount(10),
    "20%": discount(20),
    "30%": discount(30)
}

# Використання функції зі словника
price = 500
discount_type = "20%"
print(discount_functions)
discounted_price = discount_functions[discount_type](price)
print(f"Ціна зі знижкою {discount_type}: {discounted_price}")
""" Ми створюємо словник discount_functions, де кожному типу знижки "10%", "20%" та "30%" відповідає функція з 
каррінгом, що обчислює знижку. І тепер щоб застосувати знижку, ми вибираємо потрібну функцію зі словника за допомогою 
ключа discount_type і передаємо їй ціну товару. Виведення:

        Ціна зі знижкою 20%: 400.0

    Цей підхід забезпечує велику гнучкість, бо ми можемо легко додавати, видаляти або змінювати знижки в словнику 
без необхідності зміни основного коду програми. 

                        Декоратори
                        
    Є такий шаблон проектування — Декоратор. Цей шаблон полягає в тому, щоб розширювати функціонал який вже існує, 
не вносячи змін в код цього самого функціоналу.
    Декоратори в Python — це дуже потужний і корисний інструмент, який дозволяє змінювати поведінку функцій або 
методів без зміни їхнього вихідного коду. Вони є прикладом функцій вищого порядку, які приймають іншу функцію як 
аргумент та повертають нову функцію.
    Наприклад, у нас є якась дуже складна і важлива функція complicated:

def complicated(x: int, y: int) -> int:
    return x + y

    І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логування до цієї функції, виводити в 
консоль щоразу те, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.
    Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:"""
def complicated(x: int, y: int) -> int:
    return x + y

def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

complicated = logger(complicated)
# print(complicated) #<function logger.<locals>.inner at 0x00000282F3878E00>
# complicated(2, 3)
print(complicated(2, 3))
""" Декоратор logger приймає функцію як аргумент і повертає нову функцію complicated = logger(complicated). Декорована 
функція зберігає свою оригінальну функціональність, але додатково отримує нову поведінку або модифікації.
    Тепер, викликаючи complicated, ми побачимо у консолі, з якими аргументами її викликали і що вона повернула. При 
цьому, код самої complicated жодним чином не змінився і спосіб роботи з нею також.

Викликається функція: complicated: 2, 3
Функція complicated завершила виконання: 5
5

    Проте такий код не занадто легкий для читання й досить великий за обсягом. Крім того, в коді легко пропустити рядок 
complicated = logger(complicated) і не занадто просто зрозуміти, звідки виходитиме доданий до complicated функціонал.
    Щоб спростити застосування цього шаблону проектування, в Python є спеціальний синтаксис декоратора. Декоратори 
використовуються з синтаксисом @, що робить їх застосування простим та елегантним. Точно той самий код, який робить в 
точності те саме, можна записати у вигляді: """
def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
""" Функція logger є декоратором. Вона приймає функцію func і повертає нову функцію inner. Функція inner виконує 
додаткові дії (логування) до і після виконання func. При оголошенні функції complicated, ми використовуємо @logger, 
щоб застосувати декоратор. Тепер при кожному виклику complicated будуть виконуватися додаткові дії логування. Тепер 
у коді явно видно, що complicated була задекорована logger у тому самому місці, де complicated була оголошена.

    Декоратори широко використовуються для різних цілей. Основні застосування це:
        - Логування - запис інформації про виклики функцій для забезпечення прозорості та відстеження.
        - Перевірка доступу - перевірка прав користувача перед виконанням функції, щоб контролювати доступ.
        - Кешування - збереження результатів функції для підвищення ефективності та скорочення часу виконання.
        - Перевірка аргументів - аналіз та модифікація аргументів перед їх передачею функції для забезпечення 
        правильності виклику.

    В майбутньому ми побачимо, що в веб-розробці декоратори стануть нашими незмінними помічниками.
    Дуже важливо при створенні декораторів використовувати модуль functools, це необхідно для збереження метаданих 
оригінальної функції, яку ми декоруємо. Функція functools.wraps допомагає в цьому, зберігаючи інформацію про 
оригінальну функцію, як-от ім'я функції та документацію. """
from functools import wraps

def logger(func):
    @wraps(func)
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
print(complicated.__name__)
""" У цьому прикладі functools.wraps(func) застосовується до внутрішньої функції inner. Вона "копіює" метадані 
(ім'я функції, документацію тощо) від func до inner. Завдяки цьому, коли ми викликаємо print(complicated.__name__), 
ми отримуємо метадані оригінальної функції complicated, а не функції inner з декоратору logger.

    Виведення:
        Викликається функція: complicated: 2, 3
        Функція complicated завершила виконання: 5
        5
        complicated

    Це важливо для збереження очікуваної функціональності декорованої функції, особливо коли працюєте з декораторами 
у більш складних програмах або бібліотеках. Використання functools.wraps допомагає уникнути плутанини, пов'язаної з 
втратою метаданих оригінальної функції. 

                        Comprehensions


    В програмуванні досить часто необхідно створити заповнену колекцію. Зробити це одним виразом не можна, доводиться 
писати цикл. Наприклад, щоб створити список квадратів чисел від 1 до 5, треба написати наступний код:"""
sq = []
for i in range(1, 6):
    sq.append(i**2)
print("Квадрати чисел від 1 до 5",sq)

""" Виведення: Квадрати чисел від 1 до 5 [1, 4, 9, 16, 25]
    Подібні операції, які ми робимо зі змінюваними колекціями списків list, словників dict та множин set у циклі for. 
Для спрощення таких операцій в Python ввели конструкції Comprehensions .
    Comprehensions в Python - це спосіб компактного створення колекцій на основі наявних колекцій. Python підтримує 
кілька видів comprehensions: для списків (list comprehensions), множин (set comprehensions) та словників (dictionary 
comprehensions). Вони дозволяють писати вирази для створення нових колекцій з меншою кількістю коду, ніж при 
використанні циклів.

                        List Comprehensions

    List comprehensions використовуються для створення нових списків та мають наступний синтаксис:

            [new_item for item in iterable if condition]

    Як це виглядає на практиці? Попередній приклад можна записати наступним чином:"""
sq = [x**2 for x in range(1, 6)]
print("Квадрати чисел від 1 до 5",sq)
""" Створення списку квадратів чисел від 1 до 5: [1, 4, 9, 16, 25]
    
    Умова в синтаксисі дозволяє нам створювати списки за якоюсь умовою. Створимо список квадратів парних чисел від 1 до 9: """
even_squares = [x**2 for x in range(1, 10) if x % 2 == 0]
print(even_squares)
""" Виведення: [4, 16, 36, 64]
    Тут ми створюємо список квадратів чисел від 1 до 9, але тільки для парних чисел. Умова if x % 2 == 0 фільтрує 
числа, залишаючи тільки парні. Таким чином, ми отримуємо список квадратів парних чисел від 1 до 9."""

# В звичайному стилі попередній приклад прийшлось би записувати так:
even_squares = []
for x in range(1, 10):
    if x % 2 == 0:
        even_squares.append(x**2)

print(even_squares)  # Виведе [4, 16, 36, 64]
""" У цьому коді використовується цикл for для ітерації чисел від 1 до 9. Для кожного числа x перевіряється, чи є воно парним, 
тобто чи ділиться на 2 без залишку. Якщо так, його квадрат додається до списку even_squares. На виході ми отримуємо список 
квадратів усіх парних чисел у заданому діапазоні. Скільки коду вийшло, замість одного рядка Comprehensions цілих чотири!
    Як бачимо Comprehensions зазвичай коротші та легші для розуміння, ніж еквівалентні цикли. Але головне вони часто більш 
ефективні за цикли через оптимізації в Python.



