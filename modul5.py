""" 
                                        Вступ

                                        Привіт!
    У цьому модулі ми вивчимо деякі вбудовані модулі, а також структури даних і основи функціонального
програмування у Python.
    Розглянемо такі теми:
        - використання іменованих кортежів та спеціальних словників Counter та defaultdict у модулі 
        collections
        - принципи роботи структур даних стек, черга та двостороння черга
        - забезпечення точності обчислення дробів за допомогою модуля decimal
        - створення генераторів для лінивої (on-demand) генерації даних
        - концепції замикання та карування
        - основи функціонального програмування в Python
        - розширення можливостей функцій за допомогою використання декораторів
        -швидке заповнення списків, множин та словників за допомогою конструкцій comprehensions
        -використання лямбда-функцій, а також функцій map, filter, any та all.
    В результаті проходження модуля, ви значно розширете свій інструментарій та навчитесь вирішувати 
нові задачі у Python.

                                        Можливості деяких вбудованих модулів Python

                        Модуль collections
                                                                               
    У Python є пакет з додатковими колекціями, які можуть дуже знадобитися розробнику-початківцю і 
    значно розширити його арсенал. Модуль collections в Python - це вбудований модуль, який містить 
    спеціалізовані типи даних, які надають альтернативи стандартним вбудованим контейнерам. Ці 
    спеціалізовані типи даних призначені для вирішення конкретних задач програмування.

                        Іменовані кортежі

    Використання кортежів у Python для передачі даних між функціями-обробниками — це хороша та поширена 
практика. Але є одна незручність у кортежів - нам необхідно пам'ятати індексацію елементів у кортежі і 
не плутати їх порядок. Це не завжди зручно і для ситуацій, коли в кортежі є досить багато елементів, 
такий підхід ускладнює читабельність коду.
    Тому були придумані іменовані кортежі namedtuple в Python. Це розширення стандартного типу даних 
tuple, яке дозволяє виконувати доступ до елементів списку за іменем, а не за індексом. Що робить наш 
код легшим для читання та більш зрозумілим.
    Іменований кортеж створюється за допомогою функції namedtuple з модуля collections.
    У цьому прикладі Point — іменований кортеж, який має поля-імена: x та y. Тепер ми 
можемо звертатися до елементу такого кортежу за іменем:                    
"""
from collections import namedtuple

# Створення іменованого кортежу
Point = namedtuple('Point', ['x', 'y'])
# Створення екземпляра Point
p = Point(11, y=22)

# Доступ до елементів
print(p.x)  # 11
print(p.y)  # 22
# Доступ до елементів за індексом
print(p[0])  # 11
print(p[1])  # 22

""" 
    Уявимо наступний кортеж, який зберігає ім'я, прізвище, вік, місто народження та поштовий індекс:
        person = ('Mick', 'Nitch', 35, 'Boston', '01146')
    Після створення person там, де ви його використовуєте, вам потрібно пам'ятати, що ім'я на першому 
місці, а вік — на третьому. Щоб не плутатися, доведеться постійно повертатися до коду, де створюється 
person та перевіряти себе. Це незручно і спеціально для таких випадків додали іменовані кортежі.
    Розглянемо, як їх можна використовувати.
"""
import collections

# Створення іменованого кортежу Person
Person = collections.namedtuple('Person', ['first_name', 'last_name', 'age', 'birth_place', 'post_index'])

# Створення екземпляра Person
person = Person('Mick', 'Nitch', 35, 'Boston', '01146')

# Виведення різних атрибутів іменованого кортежу
print(" first name of person ", person.first_name)       
print(" post index ",person.post_index) 
print("Age", person.age)        
print(person[3])         
print("birth place",person.birth_place)
print("last name",person.last_name)

"""
        Тепер, використовуючи іменований кортеж Person, ви можете створювати кортежі, які обов'язково 
    повинні містити 5 елементів і у таких кортежів, окрім індексів, є імена. Кожен елемент кортежу може 
    бути отриманий як за іменем, так і за індексом, що забезпечує гнучкість у доступі до даних. За 
    такого підходу вам достатньо один раз визначити Person і більше не повертатися до нього, щоб 
    згадати, який елемент за що відповідає.
        Розглянемо, ще один приклад використання іменованого кортежу при представленні інформації про 
    кота. Цей код є чудовим прикладом використання іменованих кортежів для зручного та зрозумілого 
    управління даними.
"""
import collections

Cat = collections.namedtuple('Cat', ['nickname', 'age', 'owner'])

cat = Cat('Simon', 4, 'Krabat')

print(f'This is a cat {cat.nickname}, {cat.age} age, his owner {cat.owner}')
""" 
Виведення: This is a cat Simon, 4 age, his owner Krabat

    Ми використали namedtuple для створення іменованого кортежу Cat з полями nickname, age, owner. Далі 
ми створюємо змінну cat з ім'ям 'Simon', віком 4 роки і власником 'Krabat'. Виводимо інформацію про кота 
в форматованому рядку, використовуючи поля іменованого кортежу Cat. Це робить код більш організованим і 
легким для розуміння.
    Бо наприклад наступний рядок коду набагато менш інформативний в нашому випадку.
"""
print(f'This is a cat {cat[0]}, {cat[1]} age, his owner {cat[2]}')
""" 
    Іменовані кортежі в Python - це потужний інструмент для створення структур даних, які є незмінними 
    та більш зрозумілими, ніж звичайні кортежі. Вони особливо корисні для програм, які маніпулюють 
    складними наборами даних і потребують чіткої структури.

                        Counter

    Розглянемо наступну задачу. Є список в якому потрібно підрахувати кількість елементів, що в ньому 
зустрічаються. Для цього досить зручно скористатися словником. Реалізація такої задачі може виглядати 
наступним чином.                    
"""
student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
mark_counts = {}
for mark in student_marks:
    if mark in mark_counts:
        mark_counts[mark] += 1
    else:
        mark_counts[mark] = 1

print(mark_counts)
""" 
    Виведення: {4: 5, 2: 2, 6: 3, 7: 2, 3: 2, 5: 2, 1: 3}
    Але для цього завдання є більш зручний спосіб - використання класу Counter з модуля collections.
    Таке завдання зустрічається досить часто і, щоб не писати одні й ті самі 6 рядків коду постійно, у 
collections додали спеціальний словник Counter
    Counter належить до модуля collections і служить для підрахунку гешабельних об'єктів. Це особливо 
корисно, коли потрібно швидко підрахувати кількість окремих елементів у колекції, наприклад у списку, 
рядку або будь-якому іншому ітерованому об'єкті. Counter функціонує як словник, де ключами є елементи, 
а значеннями - їх кількість у колекції.
    Щоб створити Counter, просто передайте йому ітерований об'єкт. Тож попередній приклад можна 
перезаписати наступним чином:
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)
print(mark_counts)
"""
Виведення: Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})

    Один з найпопулярніших методів Counter - це most_common(), який повертає список елементів та їх 
частоту, починаючи з тих які зустрічаються найчастіше. Цей метод може бути надзвичайно корисним для 
аналізу даних, коли важливо визначити, які елементи зустрічаються найчастіше.
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2 , 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)

print(mark_counts.most_common())
print(mark_counts.most_common(1))
print(mark_counts.most_common(2))

"""
Виведення:
[(4, 4), (6, 3), (1, 3), (2, 2), (7, 2), (3, 2), (5, 2)]
[(4, 4)]
[(4, 4), (6, 3)]

    Наприклад, якщо вам потрібно підрахувати кількість кожної літери у рядку, просто передайте рядок 
безпосередньо до Counter. Тоді ви можете легко отримати доступ до кількості кожної літери за допомогою 
ключів, як у звичайному словнику.
"""
from collections import Counter

# Створення Counter з рядка
letter_count = Counter("banana")
print(letter_count)
# Виведення:
# Counter({'a': 3, 'n': 2, 'b': 1})

# Виконати підрахунок слів в тексті теж стає досить простою задачею:
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_count = Counter(words)

# Виведення слова та його частоти
for word, count in word_count.items():
    print(f"{word}: {count}")

""" Виведення:

the: 2
quick: 1
brown: 1
fox: 1
jumps: 1
over: 1
lazy: 1
dog: 1

    Використання Counter є інтуїтивно зрозумілим і водночас надзвичайно потужним для рішення багатьох 
задач, пов'язаних із підрахунком та аналізом даних.


"""

