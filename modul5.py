""" 
                                        Вступ

                                        Привіт!
    У цьому модулі ми вивчимо деякі вбудовані модулі, а також структури даних і основи функціонального
програмування у Python.
    Розглянемо такі теми:
        - використання іменованих кортежів та спеціальних словників Counter та defaultdict у модулі 
        collections
        - принципи роботи структур даних стек, черга та двостороння черга
        - забезпечення точності обчислення дробів за допомогою модуля decimal
        - створення генераторів для лінивої (on-demand) генерації даних
        - концепції замикання та карування
        - основи функціонального програмування в Python
        - розширення можливостей функцій за допомогою використання декораторів
        -швидке заповнення списків, множин та словників за допомогою конструкцій comprehensions
        -використання лямбда-функцій, а також функцій map, filter, any та all.
    В результаті проходження модуля, ви значно розширете свій інструментарій та навчитесь вирішувати 
нові задачі у Python.

                                        Можливості деяких вбудованих модулів Python

                        Модуль collections
                                                                               
    У Python є пакет з додатковими колекціями, які можуть дуже знадобитися розробнику-початківцю і 
    значно розширити його арсенал. Модуль collections в Python - це вбудований модуль, який містить 
    спеціалізовані типи даних, які надають альтернативи стандартним вбудованим контейнерам. Ці 
    спеціалізовані типи даних призначені для вирішення конкретних задач програмування.

                        Іменовані кортежі

    Використання кортежів у Python для передачі даних між функціями-обробниками — це хороша та поширена 
практика. Але є одна незручність у кортежів - нам необхідно пам'ятати індексацію елементів у кортежі і 
не плутати їх порядок. Це не завжди зручно і для ситуацій, коли в кортежі є досить багато елементів, 
такий підхід ускладнює читабельність коду.
    Тому були придумані іменовані кортежі namedtuple в Python. Це розширення стандартного типу даних 
tuple, яке дозволяє виконувати доступ до елементів списку за іменем, а не за індексом. Що робить наш 
код легшим для читання та більш зрозумілим.
    Іменований кортеж створюється за допомогою функції namedtuple з модуля collections.
    У цьому прикладі Point — іменований кортеж, який має поля-імена: x та y. Тепер ми 
можемо звертатися до елементу такого кортежу за іменем:                    
"""
from collections import namedtuple

# Створення іменованого кортежу
Point = namedtuple('Point', ['x', 'y'])
# Створення екземпляра Point
p = Point(11, y=22)

# Доступ до елементів
print(p.x)  # 11
print(p.y)  # 22
# Доступ до елементів за індексом
print(p[0])  # 11
print(p[1])  # 22

""" 
    Уявимо наступний кортеж, який зберігає ім'я, прізвище, вік, місто народження та поштовий індекс:
        person = ('Mick', 'Nitch', 35, 'Boston', '01146')
    Після створення person там, де ви його використовуєте, вам потрібно пам'ятати, що ім'я на першому 
місці, а вік — на третьому. Щоб не плутатися, доведеться постійно повертатися до коду, де створюється 
person та перевіряти себе. Це незручно і спеціально для таких випадків додали іменовані кортежі.
    Розглянемо, як їх можна використовувати.
"""
import collections

# Створення іменованого кортежу Person
Person = collections.namedtuple('Person', ['first_name', 'last_name', 'age', 'birth_place', 'post_index'])

# Створення екземпляра Person
person = Person('Mick', 'Nitch', 35, 'Boston', '01146')

# Виведення різних атрибутів іменованого кортежу
print(" first name of person ", person.first_name)       
print(" post index ",person.post_index) 
print("Age", person.age)        
print(person[3])         
print("birth place",person.birth_place)
print("last name",person.last_name)

"""
        Тепер, використовуючи іменований кортеж Person, ви можете створювати кортежі, які обов'язково 
    повинні містити 5 елементів і у таких кортежів, окрім індексів, є імена. Кожен елемент кортежу може 
    бути отриманий як за іменем, так і за індексом, що забезпечує гнучкість у доступі до даних. За 
    такого підходу вам достатньо один раз визначити Person і більше не повертатися до нього, щоб 
    згадати, який елемент за що відповідає.
        Розглянемо, ще один приклад використання іменованого кортежу при представленні інформації про 
    кота. Цей код є чудовим прикладом використання іменованих кортежів для зручного та зрозумілого 
    управління даними.
"""
import collections

Cat = collections.namedtuple('Cat', ['nickname', 'age', 'owner'])

cat = Cat('Simon', 4, 'Krabat')

print(f'This is a cat {cat.nickname}, {cat.age} age, his owner {cat.owner}')
""" 
Виведення: This is a cat Simon, 4 age, his owner Krabat

    Ми використали namedtuple для створення іменованого кортежу Cat з полями nickname, age, owner. Далі 
ми створюємо змінну cat з ім'ям 'Simon', віком 4 роки і власником 'Krabat'. Виводимо інформацію про кота 
в форматованому рядку, використовуючи поля іменованого кортежу Cat. Це робить код більш організованим і 
легким для розуміння.
    Бо наприклад наступний рядок коду набагато менш інформативний в нашому випадку.
"""
print(f'This is a cat {cat[0]}, {cat[1]} age, his owner {cat[2]}')
""" 
    Іменовані кортежі в Python - це потужний інструмент для створення структур даних, які є незмінними 
    та більш зрозумілими, ніж звичайні кортежі. Вони особливо корисні для програм, які маніпулюють 
    складними наборами даних і потребують чіткої структури.

                        Counter

    Розглянемо наступну задачу. Є список в якому потрібно підрахувати кількість елементів, що в ньому 
зустрічаються. Для цього досить зручно скористатися словником. Реалізація такої задачі може виглядати 
наступним чином.                    
"""
student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
mark_counts = {}
for mark in student_marks:
    if mark in mark_counts:
        mark_counts[mark] += 1
    else:
        mark_counts[mark] = 1

print(mark_counts)
""" 
    Виведення: {4: 5, 2: 2, 6: 3, 7: 2, 3: 2, 5: 2, 1: 3}
    Але для цього завдання є більш зручний спосіб - використання класу Counter з модуля collections.
    Таке завдання зустрічається досить часто і, щоб не писати одні й ті самі 6 рядків коду постійно, у 
collections додали спеціальний словник Counter
    Counter належить до модуля collections і служить для підрахунку гешабельних об'єктів. Це особливо 
корисно, коли потрібно швидко підрахувати кількість окремих елементів у колекції, наприклад у списку, 
рядку або будь-якому іншому ітерованому об'єкті. Counter функціонує як словник, де ключами є елементи, 
а значеннями - їх кількість у колекції.
    Щоб створити Counter, просто передайте йому ітерований об'єкт. Тож попередній приклад можна 
перезаписати наступним чином:
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)
print(mark_counts)
"""
Виведення: Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})

    Один з найпопулярніших методів Counter - це most_common(), який повертає список елементів та їх 
частоту, починаючи з тих які зустрічаються найчастіше. Цей метод може бути надзвичайно корисним для 
аналізу даних, коли важливо визначити, які елементи зустрічаються найчастіше.
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2 , 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)

print(mark_counts.most_common())
print(mark_counts.most_common(1))
print(mark_counts.most_common(2))

"""
Виведення:
[(4, 4), (6, 3), (1, 3), (2, 2), (7, 2), (3, 2), (5, 2)]
[(4, 4)]
[(4, 4), (6, 3)]

    Наприклад, якщо вам потрібно підрахувати кількість кожної літери у рядку, просто передайте рядок 
безпосередньо до Counter. Тоді ви можете легко отримати доступ до кількості кожної літери за допомогою 
ключів, як у звичайному словнику.
"""
from collections import Counter

# Створення Counter з рядка
letter_count = Counter("banana")
print(letter_count)
# Виведення:
# Counter({'a': 3, 'n': 2, 'b': 1})

# Виконати підрахунок слів в тексті теж стає досить простою задачею:
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_count = Counter(words)

# Виведення слова та його частоти
for word, count in word_count.items():
    print(f"{word}: {count}")

""" Виведення:

the: 2
quick: 1
brown: 1
fox: 1
jumps: 1
over: 1
lazy: 1
dog: 1

    Використання Counter є інтуїтивно зрозумілим і водночас надзвичайно потужним для рішення багатьох 
задач, пов'язаних із підрахунком та аналізом даних.

                        defaultdict

    Спеціальний словник defaultdict є підкласом словника dict у Python, який входить у модуль collections. 
Цей тип словника дозволяє призначити значення за замовчуванням для ключів, які ще не існують у словнику.
    У звичайному словнику Python спроба доступу до ключа, якого не існує, викликає виняток KeyError. В 
defaultdict, якщо ключ не існує, він автоматично створюється зі значенням, яке повертає функція, передана 
під час створення defaultdict.
    Під час створення defaultdict, ви повинні передати функцію, яка повертає значення за замовчуванням 
для нових ключів. Це може бути будь-який об'єкт, який може бути викликаний, наприклад, int, list, set або 
навіть ваша функція.
"""
from collections import defaultdict

# Створення defaultdict з list як фабрикою за замовчуванням
d = defaultdict(list)

# Додавання елементів до списку для кожного ключа
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

print(d)
"""
    У цьому прикладі, якщо ми звертаємось до ключа, який ще не існує, defaultdict автоматично створює 
для нього новий список і це не призводить до помилок в коді.
Виведення:  defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})

    Наступний приклад де defaultdict використовує int як функцію за замовчуванням, що означає, що кожен 
новий ключ має ініційоване значення 0.
"""
d = defaultdict(int)

# Збільшення значення для кожного ключа
d['a'] += 1
d['b'] += 1
d['a'] += 1

print(d)
"""
Виведення:  defaultdict(<class 'int'>, {'a': 2, 'b': 1})

    Навіщо це потрібно і коли може знадобиться? Наприклад, у вас є список слів і ви хочете розбити його 
на декілька списків, залежно від першої літери слова.
"""
words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = {}

for word in words:
    char = word[0]
    if char not in grouped_words:
        grouped_words[char] = []
    grouped_words[char].append(word)

print(grouped_words)

""" 
У консолі ми побачимо:
{
    'a': ['apple', 'appendix'],
    'z': ['zoo'],
    'l': ['lion', 'lama'],
    'b': ['bear', 'bet'],
    'w': ['wolf']
}

    Таким чином ми можемо отримати всі слова із words, що починаються на якусь літеру. Подібні завдання 
зустрічаються досить часто. Нам тут завжди доводиться перевіряти, чи створили ми для ключа char в 
словнику grouped_words пустий список:

 if char not in grouped_words:
    grouped_words[char] = []

    Якщо ми не зробимо таку перевірку, то операція grouped_words[char].append(word) буде призводити до 
помилки, бо за замочуванням для ключа char ніякого пустого списку не існує. А ми намагаємось щось туди 
додати.
    Щоб не перевіряти, чи є список на цю літеру в словнику grouped_words, ми можемо скористатися 
defaultdict із collections та задати значенням за замовчуванням порожній список:
"""
from collections import defaultdict

words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = defaultdict(list)

for word in words:
    char = word[0]
    grouped_words[char].append(word)

print(dict(grouped_words))

""" 
    Результат виконання буде ідентичний. defaultdict приймає у якості аргументу функцію, яка буде 
використовуватися для створення значення за замовчуванням. В цьому прикладі ми використали list, але ви 
можете передати будь-яку функцію, яка викликається без аргументів.

                        Стек

    Стек - це одна з фундаментальних структур даних у програмуванні, яка дозволяє здійснювати операції 
вставки і вилучення даних за принципом "Останнім прийшов - першим вийшов" (LIFO - Last In, First Out).
    У структурованому лінійному списку, організованому за принципом LIFO, елементи можуть додаватися та 
вибиратися тільки з одного кінця, що називається «вершиною списку». Структура LIFO може бути 
проілюстрована наступним малюнком.

    Існують основні операції стеку:
        Push - додавання елемента.
        Pop - вилучення елемента.
        Peek - перегляд верхнього елемента.
        Is Empty - перевірка стеку на порожнечу.
        Size - отримання кількості елементів у стеку.

    Проста реалізація цих команд стеку включає наступні функції:                   
"""
# Створення стеку
def create_stack():
    return []

# Перевірка на порожнечу
def is_empty(stack):
    return len(stack) == 0

# Додавання елементу
def push(stack, item):
    stack.append(item)

# Вилучення елементу
def pop(stack):
    if not is_empty(stack):
        return stack.pop()
    else:
        print("Стек порожній")

# Перегляд верхнього елемента
def peek(stack):
    if not is_empty(stack):
        return stack[-1]
    else:
        print("Стек порожній")
# Отримання розміру стеку
def size(stack):
    return len(stack)
# Спочатку створимо стек та додамо декілька елементів:
stack = create_stack()
push(stack, 'a')
push(stack, 'b')
push(stack, 'c')
# Тепер стек містить елементи ['a', 'b', 'c'], де 'c' є на вершині стеку.
# Переглянемо верхній елемент:
print(peek(stack))  # Виведе 'c'
# Видалимо верхній елемент:
print(pop(stack))  # Виведе 'c'
"""
    Тепер стек містить ['a', 'b']. Якщо ми спробуємо знову переглянути або видалити верхній елемент, ми 
отримаємо 'b'.
    Якщо ми продовжимо видаляти елементи, поки стек не стане порожнім, а потім спробуємо ще раз видалити 
або переглянути верхній елемент, обидві функції pop() та peek() виведуть повідомлення "Стек порожній".
    Стеки в програмуванні є ідеальними для задач, де потрібно відслідковувати елементи в зворотному 
порядку. Наприклад, стеки застосовуються в управлінні викликами функцій та в різноманітних алгоритмах.

                        Черга
    Черга (queue) у програмуванні — це абстрактна структура даних, яка діє за принципом "першим прийшов – 
першим вийшов" (FIFO: First In, First Out). Елементи додаються (enqueue) на один кінець структури та 
видаляються (dequeue) з іншого кінця.

    Існують основні операції для черги:
        Enqueue - додавання елемента в кінець черги.
        Dequeue - видалення елемента з початку черги.
        Front/Peek - перегляд першого елемента черги без його видалення.
        Is Empty - перевірка, чи черга порожня.
        Size - визначення кількості елементів у черзі.

    Черги широко використовуються в програмуванні для управління потоками даних та завдань, особливо коли 
порядок елементів має значення.
    В Python, чергу можна реалізувати за допомогою вбудованого типу list, хоча це не завжди найефективніший 
спосіб через високу вартість операцій Dequeue. Списки у Python реалізовані таким чином, що вибір елемента 
за індексом відбувається за константний час (дуже швидко), так само як і додавання/видалення елементу з 
кінця списку. Але ось додавання елементу в будь-яке інше місце в списку змушує Python перерахувати індекси 
усіх елементів списку до кінця. Для великих списків це може бути дуже невигідно. Ефективнішим варіантом є 
використання deque з модуля collections в якості черги.
"""
from collections import deque

# Створення черги
queue = deque()

# Enqueue: Додавання елементів
queue.append('a')
queue.append('b')
queue.append('c')

print("Черга після додавання елементів:", list(queue))

# Dequeue: Видалення елемента
print("Видалений елемент:", queue.popleft())

print("Черга після видалення елемента:", list(queue))

# Peek: Перегляд першого елемента
print("Перший елемент у черзі:", queue[0])

# IsEmpty: Перевірка на порожнечу
print("Чи черга порожня:", len(queue) == 0)

# Size: Розмір черги
print("Розмір черги:", len(queue))
"""
    Виведення:
    Черга після додавання елементів: ['a', 'b', 'c']
    Видалений елемент: a
    Черга після видалення елемента: ['b', 'c']
    Перший елемент у черзі: b
    Чи черга порожня: False
    Розмір черги: 2

    Використання deque для реалізації черги є ефективним і дозволяє швидко виконувати операції додавання
та видалення елементів з обох кінців. Це робить deque ідеальним вибором для реалізації черг у Python, 
оскільки він забезпечує високу продуктивність і простоту використання.
    У цьому прикладі ми використовуємо deque для створення черги, що дозволяє нам ефективно додавати 
елементи в кінець черги (Enqueue) і видаляти елементи з початку (Dequeue). Операція popleft() 
використовується для Dequeue, оскільки вона видаляє перший елемент з deque, відповідаючи поведінці FIFO 
черги.
    Черги, застосовують для задач, де елементи повинні бути оброблені в порядку їх надходження. Вони 
широко застосовуються для управління задачами в операційних системах, у системах черги повідомлень для 
мікросервісів, а також у графічних інтерфейсах для управління подіями.

                        Двостороння черга deque

    Двостороння черга, або Deque (скорочення від "double-ended queue"), є типом структури даних, яка 
дозволяє вставляти та видаляти елементи з обох кінців. Ця гнучкість робить Deque особливо корисною у 
багатьох сценаріях програмування.
    На відміну від звичайної черги, де елементи можна додавати та видаляти лише з одного кінця, Deque 
дозволяє проводити операції на обох кінцях. Тому deque з модуля collections реалізований таким чином, що 
операції додавання та видалення елементів є дуже ефективними, навіть для великих наборів даних.

    Основні методи deque
        append(x) - додає елемент x в кінець черги.
        appendleft(x) - додає елемент x на початок черги.
        pop() - видаляє та повертає елемент з правого кінця черги. Якщо черга порожня, викидає виняток
          IndexError.
        popleft() - видаляє та повертає елемент з лівого кінця черги. Якщо черга порожня, викидає виняток
          IndexError.
"""
from collections import deque

# Створення пустої двосторонньої черги
d = deque()

# Додаємо елементи в чергу
d.append('middle')  # Додаємо 'middle' в кінець черги
d.append('last')    # Додаємо 'last' в кінець черги
d.appendleft('first')  # Додаємо 'first' на початок черги

# Виведення поточного стану черги
print("Черга після додавання елементів:", list(d))

# Видалення та виведення останнього елемента (з правого кінця)
print("Видалений останній елемент:", d.pop())

# Видалення та виведення першого елемента (з лівого кінця)
print("Видалений перший елемент:", d.popleft())

# Виведення поточного стану черги після видалення елементів
print("Черга після видалення елементів:", list(d))
""" Виведення:

Черга після додавання елементів: ['first', 'middle', 'last']
Видалений останній елемент: last
Видалений перший елемент: first
Черга після видалення елементів: ['middle']

    Ще однією особливістю deque є можливість обмежити розмір Deque: """
from collections import deque

d = deque(maxlen=5)
for i in range(10):
    d.append(i)

print(d)
""" Виведення: deque([5, 6, 7, 8, 9], maxlen=5)

    Як видно з прикладу, нові елементи витісняють старіші, але розмір залишається незмінним. В усьому 
іншому deque веде себе точно як список Python.
    Двосторонні черги поєднують в собі можливості стеків та черг, дозволяючи додавати та видаляти елементи 
з обох кінців. Це робить їх винятково гнучкими для різних сценаріїв. Deques часто використовуються там, 
де потрібен швидкий доступ до елементів з обох кінців структури, наприклад, в алгоритмах, що вимагають 
обробки буферів або паліндромів, а також у задачах з різними пріоритетами.
    Уявімо, що у нас є список завдань на день, де кожне завдання описано як словник із двома атрибутами: 
тип завдання (швидке або повільне) та його назва. Наша задача — розподілити ці завдання таким чином, щоб 
швидкі завдання виконувалися першими. Для цього ми використаємо двосторонню чергу, яка дозволяє нам 
додавати елементи як на початок, так і в кінець черги.
tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]

    Завдання, визначені як "fast", повинні виконуватися в першу чергу, тому вони мають більший пріоритет. 
Натомість "slow" завдання можуть зачекати і ми додаємо їх в кінець черги, виконуючи після всіх швидких 
завдань.
    Мета цієї задачі — продемонструвати, як можна використовувати двосторонню чергу для контролю 
пріоритету завдань.
"""
from collections import deque

# Список завдань, де кожне завдання - це словник
tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]

# Ініціалізація черги завдань
task_queue = deque()

# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")

# Виконання завдань
while task_queue:
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")

""" 
    Розглянемо як розв'язана ця задача. Отже створюється порожня двостороння черга для зберігання завдань.

# Ініціалізація черги завдань
task_queue = deque()

    Потім ми виконуємо розподіл завдань за пріоритетом.
        Проходимося по кожному завданню в списку.
        Якщо тип завдання "fast" (швидке), додаємо його на початок черги, надаючи йому високий пріоритет.
        Якщо тип завдання "slow" (повільне), додаємо його в кінець черги, надаючи нижчий пріоритет.

# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")

    Далі блок виконання завдань. Допоки в черзі є завдання, витягуємо завдання з початку черги (з лівого 
кінця). Виконуємо завдання в порядку їх пріоритету: спочатку всі швидкі, потім повільні.

# Виконання завдань
while task_queue:
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")

    Швидкі завдання отримують перевагу, оскільки вони додаються на передню частину черги та виконуються 
першими. Повільні завдання, додані в кінець черги та чекають, поки не будуть виконані всі швидкі завдання. 
Що і демонструє процес виведення:

    Додано швидке завдання: Помити посуд
    Додано повільне завдання: Подивитись серіал
    Додано швидке завдання: Вигуляти собаку
    Додано повільне завдання: Почитати книгу
    Виконується завдання: Вигуляти собаку
    Виконується завдання: Помити посуд
    Виконується завдання: Подивитись серіал
    Виконується завдання: Почитати книгу

    Звичайно все, це можна було зробити за допомогою звичайних списків. Використання deque замість
звичайного списку для управління завданнями забезпечує більшу ефективність, особливо при частих операціях 
вставки та видалення на обох кінцях структури. На відміну від звичайних списків, де такі операції можуть 
бути повільними, особливо на початку списку, deque оптимізована для швидких вставок та видалень, що робить 
її ідеальною для задач, де потрібно динамічно керувати елементами з високим та низьким пріоритетом.

                        Контроль точності обчислень decimal

     Комп'ютер усі обчислення робить в бінарному вигляді, а десяткові числа використовуються тільки для 
"спілкування" з користувачем для зручності останнього. Через це і через те, що точність обчислень в 
комп'ютері обмежена, виникають помилки округлення під час виконання математичних операцій.
    Наприклад виконаємо наступний код:                   
"""
print(0.1 + 0.2 == 0.3)
print(0.1 + 0.2)

""" Виведення:

False
0.30000000000000004

    Перший вираз може збити вас з пантелику, оскільки математика стверджує однозначно, що 0.1 + 0.2 = 0.3. Але 
помилка округлення під час виконання обчислювальних операцій з дійсними числами у двійковій системі обчислення 
призводить до такої неоднозначності.
    Щоб контролювати точність обчислень більш явно, у Python є пакет decimal. Decimal — це клас у модулі decimal, 
який забезпечує точну арифметику з дійсними числами, вирішуючи деякі проблеми, які виникають при використанні типу 
float. Він особливо корисний для точних обчислень, таких як фінансові розрахунки, де помилки округлення можуть 
призвести до значних проблем.
    Переднє обчислення ми можемо виконати тепер так:"""
from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2") == Decimal("0.3"))
print(Decimal("0.1") + Decimal("0.2"))
"""
Виведення:
True
0.3

    Об'єкти Decimal поводяться так само, як float, але їх і не можна використовувати в одному виразі разом.
Виконання виразу на кшталт Decimal("0.1") + 0.2 призведе до помилки.
    Точність обчислень з Decimal контролюється через контекст. Можна налаштувати загальну точність для всіх 
обчислень Decimal.

from decimal import getcontext
getcontext().prec = 4

    Тепер будь-які обчислення з Decimal будуть мати точність до чотирьох знаків після коми."""
from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("1") / Decimal("7"))

getcontext().prec = 8
print(Decimal("1") / Decimal("7"))

"""
    У цьому прикладі ми вирахували вираз 1 / 7 з точністю до 6 і 8 знаків після коми відповідно. Щоб встановити 
точність обчислення, ми скористалися функцією getcontext, яка повертає поточні налаштування точності, та встановили 
налаштування prec у 6 та 8 відповідно.

Виведення:

0.142857
0.14285714

    Зверніть увагу, що ми кажемо саме до знаків після коми. Бо getcontext встановлює кількість значущих цифр.
А значущими числами можуть бути і цифри перед комою.

    ☝ Визначення значущих цифр:

       - Усі ненульові цифри є значущими: 1, 2, 3, 4, 5, 6, 7, 8, 9.
       - Нулі між ненульовими цифрами значущі: 102, 2005, 50009.
       - Провідні нулі ніколи не бувають значущими: 0,02; 001,887; 0,000515.
       - В числі з десятковою або без десяткової коми знаходяться знакові нулі (праворуч від останньої ненульової 
       цифри) за умови, якщо вони обґрунтовані точністю їх використання: 389,000; 2,02000; 5,400; 57,5400. 

    Більш докладно може прочитати про значущі цифри на wiki.
"""
from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("233") / Decimal("7"))

"""
    Виведення буде саме 6 значущих цифр.

33.2857

    Якщо ми потребуємо саме округлення чисел, нам необхідно використовувати метод quantize. Метод quantize
використовується для встановлення точності числа Decimal, заснованої на іншому числі Decimal, яке використовується 
як шаблон.
    Наприклад, якщо ви хочете округлити число до двох знаків після коми, ви використовуєте Decimal об'єкт з двома 
нулями після коми як шаблон.
"""
from decimal import Decimal, ROUND_DOWN

# Вихідне число Decimal
number = Decimal('3.14159')

# Встановлення точності до двох знаків після коми
rounded_number = number.quantize(Decimal('0.00'), rounding=ROUND_DOWN)

print(rounded_number)

"""
    У цьому прикладі число 3.14159 округляється до 3.14 з використанням методу quantize, де як шаблон для точності 
використовується Decimal('0.00'), а режим округлення встановлено як rounding=ROUND_DOWN.
    Decimal дозволяє вибирати різні режими округлення. Згідно з офіційною документацією Python, розглянемо основні 
режими:

    - ROUND_FLOOR число завжди округляє до найближчого меншого значення, незалежно від знаку числа.
    - ROUND_CEILING число завжди округляє до найближчого більшого значення, незалежно від знаку числа.
    - ROUND_HALF_DOWN числа округлюються до найближчого значення. У випадку, коли число знаходиться точно 
    посередині між двома можливими варіантами округлення (наприклад, 2,5, де можливі варіанти — 2 або 3), число 
    округляється вниз, тобто до найближчого меншого значення.
    - ROUND_HALF_UP числа округлюються до найближчого значення. Проте у випадку нічиї (коли число знаходиться точно 
    посередині між двома варіантами), число округляється вгору, тобто до найближчого більшого значення.
    - ROUND_UP число округляється від нуля. Це означає, що додатні числа округлюються до більшого, а від'ємні - до 
    більшого за модулем значення.
    - ROUND_DOWN число округляється до нуля. Тобто додатні числа округлюються до меншого, а від'ємні - до меншого за 
    модулем значення.
    - ROUND_HALF_EVEN числа округлюються до найближчого числа. Цей режим, також відомий як "банківське округлення", 
    округлює число до найближчого значення, але у випадку нічиї (коли число точно посередині між двома варіантами), 
    воно округляється до найближчого парного цілого числа. Наприклад, як 2.5 округлиться до 2, а 3.5 - до 4. Цей 
    метод зменшує сукупну помилку при серії округлень.

    За замовчуванням округлення описується константою ROUND_HALF_EVEN
"""
import decimal
from decimal import Decimal
 
number = Decimal("1.45")

# Округлення за замовчуванням до одного десяткового знаку
print("Округлення за замовчуванням ROUND_HALF_EVEN:", number.quantize(Decimal("0.0")))

# Округлення вверх при нічиї (ROUND_HALF_UP)
print("Округлення вгору ROUND_HALF_UP:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_HALF_UP))

# Округлення вниз (ROUND_FLOOR)
print("Округлення вниз ROUND_FLOOR:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_FLOOR))

# Округлення вверх (ROUND_CEILING)
print("Округлення вгору ROUND_CEILING:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_CEILING))

# Округлення до трьох десяткових знаків за замовчуванням
print("Округлення до трьох десяткових знаків:", Decimal("3.14159").quantize(Decimal("0.000")))

"""
    Виведення:

Округлення за замовчуванням ROUND_HALF_EVEN: 1.4
Округлення вгору ROUND_HALF_UP: 1.5
Округлення вниз ROUND_FLOOR: 1.4
Округлення вгору ROUND_CEILING: 1.5
Округлення до трьох десяткових знаків: 3.142

    Метод quantize часто використовується у фінансових застосунках, де необхідно точно контролювати кількість знаків 
після коми, особливо при розрахунках, які вимагають строгого дотримання певних правил округлення. Це забезпечує 
точність і відповідність вимогам, які можуть бути встановлені законодавством або стандартами обліку.
    Сам же Decimal — це потужний інструмент для точних обчислень, який надає високий рівень контролю та гнучкості. 
Його використання є критично важливим у фінансових застосунках, бухгалтерському обліку та інших областях, де помилки 
округлення можуть призводити до серйозних наслідків.
"""