""" 
                                        Вступ

                                        Привіт!
    У цьому модулі ми вивчимо деякі вбудовані модулі, а також структури даних і основи функціонального
програмування у Python.
    Розглянемо такі теми:
        - використання іменованих кортежів та спеціальних словників Counter та defaultdict у модулі 
        collections
        - принципи роботи структур даних стек, черга та двостороння черга
        - забезпечення точності обчислення дробів за допомогою модуля decimal
        - створення генераторів для лінивої (on-demand) генерації даних
        - концепції замикання та карування
        - основи функціонального програмування в Python
        - розширення можливостей функцій за допомогою використання декораторів
        -швидке заповнення списків, множин та словників за допомогою конструкцій comprehensions
        -використання лямбда-функцій, а також функцій map, filter, any та all.
    В результаті проходження модуля, ви значно розширете свій інструментарій та навчитесь вирішувати 
нові задачі у Python.

                                        Можливості деяких вбудованих модулів Python

                        Модуль collections
                                                                               
    У Python є пакет з додатковими колекціями, які можуть дуже знадобитися розробнику-початківцю і 
    значно розширити його арсенал. Модуль collections в Python - це вбудований модуль, який містить 
    спеціалізовані типи даних, які надають альтернативи стандартним вбудованим контейнерам. Ці 
    спеціалізовані типи даних призначені для вирішення конкретних задач програмування.

                        Іменовані кортежі

    Використання кортежів у Python для передачі даних між функціями-обробниками — це хороша та поширена 
практика. Але є одна незручність у кортежів - нам необхідно пам'ятати індексацію елементів у кортежі і 
не плутати їх порядок. Це не завжди зручно і для ситуацій, коли в кортежі є досить багато елементів, 
такий підхід ускладнює читабельність коду.
    Тому були придумані іменовані кортежі namedtuple в Python. Це розширення стандартного типу даних 
tuple, яке дозволяє виконувати доступ до елементів списку за іменем, а не за індексом. Що робить наш 
код легшим для читання та більш зрозумілим.
    Іменований кортеж створюється за допомогою функції namedtuple з модуля collections.
    У цьому прикладі Point — іменований кортеж, який має поля-імена: x та y. Тепер ми 
можемо звертатися до елементу такого кортежу за іменем:                    
"""
from collections import namedtuple

# Створення іменованого кортежу
Point = namedtuple('Point', ['x', 'y'])
# Створення екземпляра Point
p = Point(11, y=22)

# Доступ до елементів
print(p.x)  # 11
print(p.y)  # 22
# Доступ до елементів за індексом
print(p[0])  # 11
print(p[1])  # 22

""" 
    Уявимо наступний кортеж, який зберігає ім'я, прізвище, вік, місто народження та поштовий індекс:
        person = ('Mick', 'Nitch', 35, 'Boston', '01146')
    Після створення person там, де ви його використовуєте, вам потрібно пам'ятати, що ім'я на першому 
місці, а вік — на третьому. Щоб не плутатися, доведеться постійно повертатися до коду, де створюється 
person та перевіряти себе. Це незручно і спеціально для таких випадків додали іменовані кортежі.
    Розглянемо, як їх можна використовувати.
"""
import collections

# Створення іменованого кортежу Person
Person = collections.namedtuple('Person', ['first_name', 'last_name', 'age', 'birth_place', 'post_index'])

# Створення екземпляра Person
person = Person('Mick', 'Nitch', 35, 'Boston', '01146')

# Виведення різних атрибутів іменованого кортежу
print(" first name of person ", person.first_name)       
print(" post index ",person.post_index) 
print("Age", person.age)        
print(person[3])         
print("birth place",person.birth_place)
print("last name",person.last_name)

"""
        Тепер, використовуючи іменований кортеж Person, ви можете створювати кортежі, які обов'язково 
    повинні містити 5 елементів і у таких кортежів, окрім індексів, є імена. Кожен елемент кортежу може 
    бути отриманий як за іменем, так і за індексом, що забезпечує гнучкість у доступі до даних. За 
    такого підходу вам достатньо один раз визначити Person і більше не повертатися до нього, щоб 
    згадати, який елемент за що відповідає.
        Розглянемо, ще один приклад використання іменованого кортежу при представленні інформації про 
    кота. Цей код є чудовим прикладом використання іменованих кортежів для зручного та зрозумілого 
    управління даними.
"""
import collections

Cat = collections.namedtuple('Cat', ['nickname', 'age', 'owner'])

cat = Cat('Simon', 4, 'Krabat')

print(f'This is a cat {cat.nickname}, {cat.age} age, his owner {cat.owner}')
""" 
Виведення: This is a cat Simon, 4 age, his owner Krabat

    Ми використали namedtuple для створення іменованого кортежу Cat з полями nickname, age, owner. Далі 
ми створюємо змінну cat з ім'ям 'Simon', віком 4 роки і власником 'Krabat'. Виводимо інформацію про кота 
в форматованому рядку, використовуючи поля іменованого кортежу Cat. Це робить код більш організованим і 
легким для розуміння.
    Бо наприклад наступний рядок коду набагато менш інформативний в нашому випадку.
"""
print(f'This is a cat {cat[0]}, {cat[1]} age, his owner {cat[2]}')
""" 
    Іменовані кортежі в Python - це потужний інструмент для створення структур даних, які є незмінними 
    та більш зрозумілими, ніж звичайні кортежі. Вони особливо корисні для програм, які маніпулюють 
    складними наборами даних і потребують чіткої структури.

                        Counter

    Розглянемо наступну задачу. Є список в якому потрібно підрахувати кількість елементів, що в ньому 
зустрічаються. Для цього досить зручно скористатися словником. Реалізація такої задачі може виглядати 
наступним чином.                    
"""
student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
mark_counts = {}
for mark in student_marks:
    if mark in mark_counts:
        mark_counts[mark] += 1
    else:
        mark_counts[mark] = 1

print(mark_counts)
""" 
    Виведення: {4: 5, 2: 2, 6: 3, 7: 2, 3: 2, 5: 2, 1: 3}
    Але для цього завдання є більш зручний спосіб - використання класу Counter з модуля collections.
    Таке завдання зустрічається досить часто і, щоб не писати одні й ті самі 6 рядків коду постійно, у 
collections додали спеціальний словник Counter
    Counter належить до модуля collections і служить для підрахунку гешабельних об'єктів. Це особливо 
корисно, коли потрібно швидко підрахувати кількість окремих елементів у колекції, наприклад у списку, 
рядку або будь-якому іншому ітерованому об'єкті. Counter функціонує як словник, де ключами є елементи, 
а значеннями - їх кількість у колекції.
    Щоб створити Counter, просто передайте йому ітерований об'єкт. Тож попередній приклад можна 
перезаписати наступним чином:
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)
print(mark_counts)
"""
Виведення: Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})

    Один з найпопулярніших методів Counter - це most_common(), який повертає список елементів та їх 
частоту, починаючи з тих які зустрічаються найчастіше. Цей метод може бути надзвичайно корисним для 
аналізу даних, коли важливо визначити, які елементи зустрічаються найчастіше.
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2 , 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)

print(mark_counts.most_common())
print(mark_counts.most_common(1))
print(mark_counts.most_common(2))

"""
Виведення:
[(4, 4), (6, 3), (1, 3), (2, 2), (7, 2), (3, 2), (5, 2)]
[(4, 4)]
[(4, 4), (6, 3)]

    Наприклад, якщо вам потрібно підрахувати кількість кожної літери у рядку, просто передайте рядок 
безпосередньо до Counter. Тоді ви можете легко отримати доступ до кількості кожної літери за допомогою 
ключів, як у звичайному словнику.
"""
from collections import Counter

# Створення Counter з рядка
letter_count = Counter("banana")
print(letter_count)
# Виведення:
# Counter({'a': 3, 'n': 2, 'b': 1})

# Виконати підрахунок слів в тексті теж стає досить простою задачею:
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_count = Counter(words)

# Виведення слова та його частоти
for word, count in word_count.items():
    print(f"{word}: {count}")

""" Виведення:

the: 2
quick: 1
brown: 1
fox: 1
jumps: 1
over: 1
lazy: 1
dog: 1

    Використання Counter є інтуїтивно зрозумілим і водночас надзвичайно потужним для рішення багатьох 
задач, пов'язаних із підрахунком та аналізом даних.

                        defaultdict

    Спеціальний словник defaultdict є підкласом словника dict у Python, який входить у модуль collections. 
Цей тип словника дозволяє призначити значення за замовчуванням для ключів, які ще не існують у словнику.
    У звичайному словнику Python спроба доступу до ключа, якого не існує, викликає виняток KeyError. В 
defaultdict, якщо ключ не існує, він автоматично створюється зі значенням, яке повертає функція, передана 
під час створення defaultdict.
    Під час створення defaultdict, ви повинні передати функцію, яка повертає значення за замовчуванням 
для нових ключів. Це може бути будь-який об'єкт, який може бути викликаний, наприклад, int, list, set або 
навіть ваша функція.
"""
from collections import defaultdict

# Створення defaultdict з list як фабрикою за замовчуванням
d = defaultdict(list)

# Додавання елементів до списку для кожного ключа
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

print(d)
"""
    У цьому прикладі, якщо ми звертаємось до ключа, який ще не існує, defaultdict автоматично створює 
для нього новий список і це не призводить до помилок в коді.
Виведення:  defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})

    Наступний приклад де defaultdict використовує int як функцію за замовчуванням, що означає, що кожен 
новий ключ має ініційоване значення 0.
"""
d = defaultdict(int)

# Збільшення значення для кожного ключа
d['a'] += 1
d['b'] += 1
d['a'] += 1

print(d)
"""
Виведення:  defaultdict(<class 'int'>, {'a': 2, 'b': 1})

    Навіщо це потрібно і коли може знадобиться? Наприклад, у вас є список слів і ви хочете розбити його 
на декілька списків, залежно від першої літери слова.
"""
words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = {}

for word in words:
    char = word[0]
    if char not in grouped_words:
        grouped_words[char] = []
    grouped_words[char].append(word)

print(grouped_words)

""" 
У консолі ми побачимо:
{
    'a': ['apple', 'appendix'],
    'z': ['zoo'],
    'l': ['lion', 'lama'],
    'b': ['bear', 'bet'],
    'w': ['wolf']
}

    Таким чином ми можемо отримати всі слова із words, що починаються на якусь літеру. Подібні завдання 
зустрічаються досить часто. Нам тут завжди доводиться перевіряти, чи створили ми для ключа char в 
словнику grouped_words пустий список:

 if char not in grouped_words:
    grouped_words[char] = []

    Якщо ми не зробимо таку перевірку, то операція grouped_words[char].append(word) буде призводити до 
помилки, бо за замочуванням для ключа char ніякого пустого списку не існує. А ми намагаємось щось туди 
додати.
    Щоб не перевіряти, чи є список на цю літеру в словнику grouped_words, ми можемо скористатися 
defaultdict із collections та задати значенням за замовчуванням порожній список:
"""
from collections import defaultdict

words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = defaultdict(list)

for word in words:
    char = word[0]
    grouped_words[char].append(word)

print(dict(grouped_words))

""" 
    Результат виконання буде ідентичний. defaultdict приймає у якості аргументу функцію, яка буде 
використовуватися для створення значення за замовчуванням. В цьому прикладі ми використали list, але ви 
можете передати будь-яку функцію, яка викликається без аргументів.

                        Стек

    Стек - це одна з фундаментальних структур даних у програмуванні, яка дозволяє здійснювати операції 
вставки і вилучення даних за принципом "Останнім прийшов - першим вийшов" (LIFO - Last In, First Out).
    У структурованому лінійному списку, організованому за принципом LIFO, елементи можуть додаватися та 
вибиратися тільки з одного кінця, що називається «вершиною списку». Структура LIFO може бути 
проілюстрована наступним малюнком.

    Існують основні операції стеку:
        Push - додавання елемента.
        Pop - вилучення елемента.
        Peek - перегляд верхнього елемента.
        Is Empty - перевірка стеку на порожнечу.
        Size - отримання кількості елементів у стеку.

    Проста реалізація цих команд стеку включає наступні функції:                   
"""
# Створення стеку
def create_stack():
    return []

# Перевірка на порожнечу
def is_empty(stack):
    return len(stack) == 0

# Додавання елементу
def push(stack, item):
    stack.append(item)

# Вилучення елементу
def pop(stack):
    if not is_empty(stack):
        return stack.pop()
    else:
        print("Стек порожній")

# Перегляд верхнього елемента
def peek(stack):
    if not is_empty(stack):
        return stack[-1]
    else:
        print("Стек порожній")
# Отримання розміру стеку
def size(stack):
    return len(stack)
# Спочатку створимо стек та додамо декілька елементів:
stack = create_stack()
push(stack, 'a')
push(stack, 'b')
push(stack, 'c')
# Тепер стек містить елементи ['a', 'b', 'c'], де 'c' є на вершині стеку.
# Переглянемо верхній елемент:
print(peek(stack))  # Виведе 'c'
# Видалимо верхній елемент:
print(pop(stack))  # Виведе 'c'
"""
    Тепер стек містить ['a', 'b']. Якщо ми спробуємо знову переглянути або видалити верхній елемент, ми 
отримаємо 'b'.
    Якщо ми продовжимо видаляти елементи, поки стек не стане порожнім, а потім спробуємо ще раз видалити 
або переглянути верхній елемент, обидві функції pop() та peek() виведуть повідомлення "Стек порожній".
    Стеки в програмуванні є ідеальними для задач, де потрібно відслідковувати елементи в зворотному 
порядку. Наприклад, стеки застосовуються в управлінні викликами функцій та в різноманітних алгоритмах.

                        Черга
    Черга (queue) у програмуванні — це абстрактна структура даних, яка діє за принципом "першим прийшов – 
першим вийшов" (FIFO: First In, First Out). Елементи додаються (enqueue) на один кінець структури та 
видаляються (dequeue) з іншого кінця.

    Існують основні операції для черги:
        Enqueue - додавання елемента в кінець черги.
        Dequeue - видалення елемента з початку черги.
        Front/Peek - перегляд першого елемента черги без його видалення.
        Is Empty - перевірка, чи черга порожня.
        Size - визначення кількості елементів у черзі.

    Черги широко використовуються в програмуванні для управління потоками даних та завдань, особливо коли 
порядок елементів має значення.
    В Python, чергу можна реалізувати за допомогою вбудованого типу list, хоча це не завжди найефективніший 
спосіб через високу вартість операцій Dequeue. Списки у Python реалізовані таким чином, що вибір елемента 
за індексом відбувається за константний час (дуже швидко), так само як і додавання/видалення елементу з 
кінця списку. Але ось додавання елементу в будь-яке інше місце в списку змушує Python перерахувати індекси 
усіх елементів списку до кінця. Для великих списків це може бути дуже невигідно. Ефективнішим варіантом є 
використання deque з модуля collections в якості черги.
"""
from collections import deque

# Створення черги
queue = deque()

# Enqueue: Додавання елементів
queue.append('a')
queue.append('b')
queue.append('c')

print("Черга після додавання елементів:", list(queue))

# Dequeue: Видалення елемента
print("Видалений елемент:", queue.popleft())

print("Черга після видалення елемента:", list(queue))

# Peek: Перегляд першого елемента
print("Перший елемент у черзі:", queue[0])

# IsEmpty: Перевірка на порожнечу
print("Чи черга порожня:", len(queue) == 0)

# Size: Розмір черги
print("Розмір черги:", len(queue))
"""
    Виведення:
    Черга після додавання елементів: ['a', 'b', 'c']
    Видалений елемент: a
    Черга після видалення елемента: ['b', 'c']
    Перший елемент у черзі: b
    Чи черга порожня: False
    Розмір черги: 2

    Використання deque для реалізації черги є ефективним і дозволяє швидко виконувати операції додавання
та видалення елементів з обох кінців. Це робить deque ідеальним вибором для реалізації черг у Python, 
оскільки він забезпечує високу продуктивність і простоту використання.
    У цьому прикладі ми використовуємо deque для створення черги, що дозволяє нам ефективно додавати 
елементи в кінець черги (Enqueue) і видаляти елементи з початку (Dequeue). Операція popleft() 
використовується для Dequeue, оскільки вона видаляє перший елемент з deque, відповідаючи поведінці FIFO 
черги.
    Черги, застосовують для задач, де елементи повинні бути оброблені в порядку їх надходження. Вони 
широко застосовуються для управління задачами в операційних системах, у системах черги повідомлень для 
мікросервісів, а також у графічних інтерфейсах для управління подіями.
"""
