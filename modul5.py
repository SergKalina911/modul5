""" 
                                        Вступ

                                        Привіт!
    У цьому модулі ми вивчимо деякі вбудовані модулі, а також структури даних і основи функціонального
програмування у Python.
    Розглянемо такі теми:
        - використання іменованих кортежів та спеціальних словників Counter та defaultdict у модулі 
        collections
        - принципи роботи структур даних стек, черга та двостороння черга
        - забезпечення точності обчислення дробів за допомогою модуля decimal
        - створення генераторів для лінивої (on-demand) генерації даних
        - концепції замикання та карування
        - основи функціонального програмування в Python
        - розширення можливостей функцій за допомогою використання декораторів
        -швидке заповнення списків, множин та словників за допомогою конструкцій comprehensions
        -використання лямбда-функцій, а також функцій map, filter, any та all.
    В результаті проходження модуля, ви значно розширете свій інструментарій та навчитесь вирішувати 
нові задачі у Python.

                                        Можливості деяких вбудованих модулів Python

                        Модуль collections
                                                                               
    У Python є пакет з додатковими колекціями, які можуть дуже знадобитися розробнику-початківцю і 
    значно розширити його арсенал. Модуль collections в Python - це вбудований модуль, який містить 
    спеціалізовані типи даних, які надають альтернативи стандартним вбудованим контейнерам. Ці 
    спеціалізовані типи даних призначені для вирішення конкретних задач програмування.

                        Іменовані кортежі

    Використання кортежів у Python для передачі даних між функціями-обробниками — це хороша та поширена 
практика. Але є одна незручність у кортежів - нам необхідно пам'ятати індексацію елементів у кортежі і 
не плутати їх порядок. Це не завжди зручно і для ситуацій, коли в кортежі є досить багато елементів, 
такий підхід ускладнює читабельність коду.
    Тому були придумані іменовані кортежі namedtuple в Python. Це розширення стандартного типу даних 
tuple, яке дозволяє виконувати доступ до елементів списку за іменем, а не за індексом. Що робить наш 
код легшим для читання та більш зрозумілим.
    Іменований кортеж створюється за допомогою функції namedtuple з модуля collections.
    У цьому прикладі Point — іменований кортеж, який має поля-імена: x та y. Тепер ми 
можемо звертатися до елементу такого кортежу за іменем:                    
"""
from collections import namedtuple

# Створення іменованого кортежу
Point = namedtuple('Point', ['x', 'y'])
# Створення екземпляра Point
p = Point(11, y=22)

# Доступ до елементів
print(p.x)  # 11
print(p.y)  # 22
# Доступ до елементів за індексом
print(p[0])  # 11
print(p[1])  # 22

""" 
    Уявимо наступний кортеж, який зберігає ім'я, прізвище, вік, місто народження та поштовий індекс:
        person = ('Mick', 'Nitch', 35, 'Boston', '01146')
    Після створення person там, де ви його використовуєте, вам потрібно пам'ятати, що ім'я на першому 
місці, а вік — на третьому. Щоб не плутатися, доведеться постійно повертатися до коду, де створюється 
person та перевіряти себе. Це незручно і спеціально для таких випадків додали іменовані кортежі.
    Розглянемо, як їх можна використовувати.
"""
import collections

# Створення іменованого кортежу Person
Person = collections.namedtuple('Person', ['first_name', 'last_name', 'age', 'birth_place', 'post_index'])

# Створення екземпляра Person
person = Person('Mick', 'Nitch', 35, 'Boston', '01146')

# Виведення різних атрибутів іменованого кортежу
print(" first name of person ", person.first_name)       
print(" post index ",person.post_index) 
print("Age", person.age)        
print(person[3])         
print("birth place",person.birth_place)
print("last name",person.last_name)

"""
        Тепер, використовуючи іменований кортеж Person, ви можете створювати кортежі, які обов'язково 
    повинні містити 5 елементів і у таких кортежів, окрім індексів, є імена. Кожен елемент кортежу може 
    бути отриманий як за іменем, так і за індексом, що забезпечує гнучкість у доступі до даних. За 
    такого підходу вам достатньо один раз визначити Person і більше не повертатися до нього, щоб 
    згадати, який елемент за що відповідає.
        Розглянемо, ще один приклад використання іменованого кортежу при представленні інформації про 
    кота. Цей код є чудовим прикладом використання іменованих кортежів для зручного та зрозумілого 
    управління даними.
"""
import collections

Cat = collections.namedtuple('Cat', ['nickname', 'age', 'owner'])

cat = Cat('Simon', 4, 'Krabat')

print(f'This is a cat {cat.nickname}, {cat.age} age, his owner {cat.owner}')
""" 
Виведення: This is a cat Simon, 4 age, his owner Krabat

    Ми використали namedtuple для створення іменованого кортежу Cat з полями nickname, age, owner. Далі 
ми створюємо змінну cat з ім'ям 'Simon', віком 4 роки і власником 'Krabat'. Виводимо інформацію про кота 
в форматованому рядку, використовуючи поля іменованого кортежу Cat. Це робить код більш організованим і 
легким для розуміння.
    Бо наприклад наступний рядок коду набагато менш інформативний в нашому випадку.
"""
print(f'This is a cat {cat[0]}, {cat[1]} age, his owner {cat[2]}')
""" 
    Іменовані кортежі в Python - це потужний інструмент для створення структур даних, які є незмінними 
    та більш зрозумілими, ніж звичайні кортежі. Вони особливо корисні для програм, які маніпулюють 
    складними наборами даних і потребують чіткої структури.

                        Counter

    Розглянемо наступну задачу. Є список в якому потрібно підрахувати кількість елементів, що в ньому 
зустрічаються. Для цього досить зручно скористатися словником. Реалізація такої задачі може виглядати 
наступним чином.                    
"""
student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
mark_counts = {}
for mark in student_marks:
    if mark in mark_counts:
        mark_counts[mark] += 1
    else:
        mark_counts[mark] = 1

print(mark_counts)
""" 
    Виведення: {4: 5, 2: 2, 6: 3, 7: 2, 3: 2, 5: 2, 1: 3}
    Але для цього завдання є більш зручний спосіб - використання класу Counter з модуля collections.
    Таке завдання зустрічається досить часто і, щоб не писати одні й ті самі 6 рядків коду постійно, у 
collections додали спеціальний словник Counter
    Counter належить до модуля collections і служить для підрахунку гешабельних об'єктів. Це особливо 
корисно, коли потрібно швидко підрахувати кількість окремих елементів у колекції, наприклад у списку, 
рядку або будь-якому іншому ітерованому об'єкті. Counter функціонує як словник, де ключами є елементи, 
а значеннями - їх кількість у колекції.
    Щоб створити Counter, просто передайте йому ітерований об'єкт. Тож попередній приклад можна 
перезаписати наступним чином:
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)
print(mark_counts)
"""
Виведення: Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})

    Один з найпопулярніших методів Counter - це most_common(), який повертає список елементів та їх 
частоту, починаючи з тих які зустрічаються найчастіше. Цей метод може бути надзвичайно корисним для 
аналізу даних, коли важливо визначити, які елементи зустрічаються найчастіше.
"""
import collections

student_marks = [4, 2, 4, 6, 7, 4, 2 , 3, 4, 5, 6, 6, 7 , 1, 1, 1, 3, 5]
mark_counts = collections.Counter(student_marks)

print(mark_counts.most_common())
print(mark_counts.most_common(1))
print(mark_counts.most_common(2))

"""
Виведення:
[(4, 4), (6, 3), (1, 3), (2, 2), (7, 2), (3, 2), (5, 2)]
[(4, 4)]
[(4, 4), (6, 3)]

    Наприклад, якщо вам потрібно підрахувати кількість кожної літери у рядку, просто передайте рядок 
безпосередньо до Counter. Тоді ви можете легко отримати доступ до кількості кожної літери за допомогою 
ключів, як у звичайному словнику.
"""
from collections import Counter

# Створення Counter з рядка
letter_count = Counter("banana")
print(letter_count)
# Виведення:
# Counter({'a': 3, 'n': 2, 'b': 1})

# Виконати підрахунок слів в тексті теж стає досить простою задачею:
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_count = Counter(words)

# Виведення слова та його частоти
for word, count in word_count.items():
    print(f"{word}: {count}")

""" Виведення:

the: 2
quick: 1
brown: 1
fox: 1
jumps: 1
over: 1
lazy: 1
dog: 1

    Використання Counter є інтуїтивно зрозумілим і водночас надзвичайно потужним для рішення багатьох 
задач, пов'язаних із підрахунком та аналізом даних.

                        defaultdict

    Спеціальний словник defaultdict є підкласом словника dict у Python, який входить у модуль collections. 
Цей тип словника дозволяє призначити значення за замовчуванням для ключів, які ще не існують у словнику.
    У звичайному словнику Python спроба доступу до ключа, якого не існує, викликає виняток KeyError. В 
defaultdict, якщо ключ не існує, він автоматично створюється зі значенням, яке повертає функція, передана 
під час створення defaultdict.
    Під час створення defaultdict, ви повинні передати функцію, яка повертає значення за замовчуванням 
для нових ключів. Це може бути будь-який об'єкт, який може бути викликаний, наприклад, int, list, set або 
навіть ваша функція.
"""
from collections import defaultdict

# Створення defaultdict з list як фабрикою за замовчуванням
d = defaultdict(list)

# Додавання елементів до списку для кожного ключа
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

print(d)
"""
    У цьому прикладі, якщо ми звертаємось до ключа, який ще не існує, defaultdict автоматично створює 
для нього новий список і це не призводить до помилок в коді.
Виведення:  defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})

    Наступний приклад де defaultdict використовує int як функцію за замовчуванням, що означає, що кожен 
новий ключ має ініційоване значення 0.
"""
d = defaultdict(int)

# Збільшення значення для кожного ключа
d['a'] += 1
d['b'] += 1
d['a'] += 1

print(d)
"""
Виведення:  defaultdict(<class 'int'>, {'a': 2, 'b': 1})

    Навіщо це потрібно і коли може знадобиться? Наприклад, у вас є список слів і ви хочете розбити його 
на декілька списків, залежно від першої літери слова.
"""
words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = {}

for word in words:
    char = word[0]
    if char not in grouped_words:
        grouped_words[char] = []
    grouped_words[char].append(word)

print(grouped_words)

""" 
У консолі ми побачимо:
{
    'a': ['apple', 'appendix'],
    'z': ['zoo'],
    'l': ['lion', 'lama'],
    'b': ['bear', 'bet'],
    'w': ['wolf']
}

    Таким чином ми можемо отримати всі слова із words, що починаються на якусь літеру. Подібні завдання 
зустрічаються досить часто. Нам тут завжди доводиться перевіряти, чи створили ми для ключа char в 
словнику grouped_words пустий список:

 if char not in grouped_words:
    grouped_words[char] = []

    Якщо ми не зробимо таку перевірку, то операція grouped_words[char].append(word) буде призводити до 
помилки, бо за замочуванням для ключа char ніякого пустого списку не існує. А ми намагаємось щось туди 
додати.
    Щоб не перевіряти, чи є список на цю літеру в словнику grouped_words, ми можемо скористатися 
defaultdict із collections та задати значенням за замовчуванням порожній список:
"""
from collections import defaultdict

words = ['apple', 'zoo', 'lion', 'lama', 'bear', 'bet', 'wolf', 'appendix']
grouped_words = defaultdict(list)

for word in words:
    char = word[0]
    grouped_words[char].append(word)

print(dict(grouped_words))

""" 
    Результат виконання буде ідентичний. defaultdict приймає у якості аргументу функцію, яка буде 
використовуватися для створення значення за замовчуванням. В цьому прикладі ми використали list, але ви 
можете передати будь-яку функцію, яка викликається без аргументів.


"""